# bfs

- https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)

- https://leetcode.com/problems/subsets (\*)
- complex:
- why we don't push ele in the dfs base / boundary check?
- why we push ele in the dfs loop?
- because we formt the path in dfs loop
- it is already formed, so no need to push ele in dfs base
- simple:
- see subset ii
- motion:
- case 1:
- [1, 2]
- st: arr: [1, 2]
- st: lo_path: []
- st: res: []
- at [] (el_x) -> 1 OR 2
- to 1 (i=0; 1; p: [1]) -> at 1 (el_x) -> to 2 (i=-1; 2; p: [1, 2]) -> at [1, 2], el, BT
- to 2 (i=1; 2; p: [2]) -> at [2], el, BT

- https://leetcode.com/problems/subsets-ii/ (\*)
- complex:
- simple:
- ns.sort (l: preprocess: 1. b(g); 2. sort*)
- x
- dfs param, ind (l: travel, bring compass)
- base_case (l: life reaches end, highlight)
- loop (i=ind; i<ns.len...) (l: gen paths: 1. dir; 2. edges; 3. .. 4. sequence arr (1. pick 1st; 2. pick same; 3. pick next*)
- if ns[i-1] === ns[i] (l: this universe, someone starts (used[i] == true), continue; u start (ns[i-1] == ns[i]) violate)
- p1.push(path)
- res.push(p1)
- l: 1. subset === portion of path*; 2. permutation === full path
- start_func (l: dfs start: 1. pt*; 2. str; 3. arr*)
- res.unshift([]) (l: 1. special case*; 2. shortcut)
- motion:
- case 1:
- [1, 1]
- at [] (el_x) ->
- to 1 (i=0; 1; rep_x; p:[1]) OR to 1 (i=1; 1; rep_*_same_dfs_level; next, el, BT)
- at 1 (el_x) ->
- to 1 (i=1; 1; rep_x; p:[1, 1]) -> [1, 1] (el_*; next, el, BT) 

- https://leetcode.com/problems/permutations (\*)
- complex:
- why used arr is so good in dfs
- we can use path_arr.includes(ele) to achieve unique
- if there are repeated num, we know exactly who used / who not used
- for dfs loop, why i=0? why we re-scan from zero?
- because if i=start_ind, we skip / miss many elements
- we want to have all elements
- why not dfs(i+1, path)?
- because i+1 will skip many elements
- why used[ind] = true -> dfs -> used[ind] = false?
- because dfs in the middle
- simple:
- const res = [] (l: 1. g_track*....)
- x
- dfs
- base_case (l: life reaches end, highlight)
- sequnce arr loop (l: gen paths: 1. dir; 2. edges; 3. arr; 4. do/!do; 5. sequence arr (1. pick 1st*; 2. pick same; 3. pick next)
- if used[i] === true
- l: interview (avoid same)
- l: travek, mark arrive
- start_func
- sort (l: preprocess: 1. b(g); 2. sort)
- used = new Arr
- l: travel, mark arrive
- l: arr (reset) === arr (no reset)
- l: dfs start: 1. pt; 2. str; 3. arr (path)*
- motion:
- case 1:
- [0, 1]
- st: grid: [0, 1]
- st: lo_seen: [f, f]
- st: lo_path: []
- st: res: []
- at [] (return_x) -> 0 (seen_x; set_seen, [t, f]; p: [0]; ...) OR 1 (seen_x; ss, [f, t]; p: [1]; ...)
- at 0 (re_x) -> 0 (s_*, next_iteration) OR 1 (s_x; ss, [t, t]; p: [0, 1]; ...) -> [0, 1] (re_*; reset [t, f]; BT)
- now back at 1 (on right, re_x) -> 0 (s_x; ss, [t, t]; p: [1, 0]; ...) OR 1 (re_*, next, end_loop; BT)
- at 0 (bottom), [1, 0] (re_*; reset [f_the_zero, t]; BT)

- https://leetcode.com/problems/permutations-ii (\*)
- complex:
- why we have 2 ways to acc path?
- 1. in base / boundary check, path.slice(0), res.push(path)
- this is easiest, because we just copy
- but waste mem
- 2. we don't copy in base / boundary check, we use single path arr (global)
- path.push() -> dfs -> path.pop()
- save mem, but a bit confused
- why in loop, (i=0 && ns[i-1] === ns[i] && used[i-1] === true) con, is to use LAST ELEMENT?
- for last same ele, from 0 to last same ele, used[i-1] === false (always)
- so we can form its own unique path
- all prev same eles, are duplicated
- simple:
- top of func
- l: preprocess: 1. b(g); 2. sort*
- const res = [] (l: 1. g_track*; 2. init track; 3. level track)
- const path = [];
- l: arr (reset) === arr (no reset)
- l: sub path === parallel universe
- const used = arr(ns.len)
- l: arr (reset) === arr (no reset)
- l: sub path === parallel universe
- l: travel, mark arrive
- x
- dfs
- base_case (l: life reaches end, highlight)
- return (l: 1. re nothing*....)
- sequence arr
- l: gen paths: 1. dir; 2. edges; 3. arr; 4. do/!do; 5. sequence arr* (1. pick 1st*; 2. pick same; 3. pick next)
- if used[i] === true -> con
- l: inteview (avoid same)
- l: travel, mark arrive
- used[i-1] === true && ns[i-1] === ns[i]
- l: this universe, someone starts (used[i-1] == true) path, continue; u start (ns[i-1] === ns[i], violate his path)
- l: mark -> travel -> !mark
- start_func
- dfs([]) (l: dfs start: 1. pt; 2. str; 3. arr*)
- motion:
- case 1:
- [1, 1]
- st: arr: [1, 1]
- st: lo_seen: [f, f]
- st: lo_path: []
- st: res
- in_order -> lo_seen[i-1] === true && arr[i] === arr[i-1]
- at [], re_x -> 1 (seen_x; in_order_*; [t, f]; p: [1]) OR 1 (seen_x; order_x; next, el, BT)
- at 1 (re_x) -> 1 (seen_*; con) OR 1 (seen_x; order_*; [t, t]; p: [1, 1])
- at [1, 1] (re_*, BT)
- lo_seen: [t, f] (unset seen) and p: [1] (pop ele)

- https://leetcode.com/problems/combination-sum (\*)
- complex:
- why we cannot use ind >= arr.length, instead use acc_sum >= tar?
- because ind can be the same index, repeat again and again
- why we use same_dfs_i?
- because same num can be used to form sum
- simple:
- see combination ii
- l: 1. pick start; 2. pick same*; 3. pick next
- motion:
- case 1:
- [2, 3, 6, 7] (no repeated num, but repeated pick); tar = 7
- sum 0 -> 2, 3, 6, 7
- at 2 -> 4, 5, 8_x, 9_x
- at 4 -> 6, 7_* (p: 2 2 3), 10_x, 11_x
- at 6 -> 8_x, 9_x, 12_x, 13_x; BT
- x
- BT at 5 -> 5+3_x (must use min 3), 6+3_x, 7+3_x; BT
- x
- BT at 3 -> 3+3, 3+6_x, 3+7_x
- at 6 -> 6+3_x
- x
- at 6 -> 6+6_x
- at 7_* (p: 7) 

- https://leetcode.com/problems/combination-sum-ii (\*)
- complex:
- in dfs loop, why we put i > start_ind in the con statement (curr and prev ele same same)?
- why not put loop(i=ind+1, i<arr.length)?
- or why not put loop(i=ind, i<arr.length-1)?
- because put i > start_ind in the con statement, we can use this single ele, this single ele will be pushed to path arr, it bypass the con statement
- why in loop, if(i > ind && ns[i-1] === n[i]) continue, why i > ind is to use FIRST ELEMENT?
- because i=ind, is to be used; later same ele skips
- simple:
- res = [] (l: 1. g_track*; 2. init track; 3. level track)
- x
- dfs(ind, path)
- ind (l: in travel, we bring compass)
- path (l: sub path === parallel universe)
- if tmp_sum > tar -> return (l: far away from home, time to back home)
- if tmp_sum === tar -> .. (l: far away from home, time back home)
- res.push(path) (l: life reaches end, highlight)
- return (l: 1. re nothing*; 2. re overall bit/every; 3. re states)
- the dfs level loop
- l: 1. pick start; 2. pick same; 3. pick next*
- l: gen paths: 1. ... 2. ...; 3. ...; 4. horizontal ele merge -> vertical next ele; 5. horizontal 1 by 1 -> vertical next ele
- if i > ind && a[i-1] == a[i] (l: parallel universe, someone starts the path and continue; if u take path, violate his universe)
- start_func
- l: preprocess: 1. b(g); 2. sort
- start_func_dfs (l: dfs start: 1. pt*; 2. str; 3. arr*, etc)
- motion:
- case 1:
- [1, 2, 2] (repeated num, but not repeat pick); tar = 3
- sum 0 (> tar_x, == tar_x, end_loop_x); -> 1 (repeat_x, p: [1]); -> 2 (rep_x, p: [2]); -> 2 (rep_*, BT)
- at 1 (> tar_x, == tar_x, el_x) -> 2 (rep_x, p: [1, 2]); -> 2 (rep_same_level_*, BT)
- at 3 (> tar_x, == tar_*, BT)
- at 2 (the original 2; > tar_x; == tar_x, el_x) -> 2 (rep_x, p: [2, 2]);
- at 4 (> tar_*, BT)

- https://leetcode.com/problems/palindrome-partitioning (\*)
- complex:
- for func isPal(), why ++i and --j?
- because if i and j not move, inifinite loop
- why substring(start_ind, end_ind) become diff dfs path?
- because they are diff possible, diff path
- simple:
- helper_func, isPal (l: two persons meet each other in the middle)
- res = [] (l: 1. g_track*; 2. init track; 3. level track)
- x
- dfs(ind, path) (l: sub path === parallel universe)
- base_case (l: life reaches end, highlight)
- base_case re (l: 1. re nothing*; 2. re overall bit/every ...)
- the_merge_char_loop (l: horizontal has many solutions (char merge), vertical has even more solutions (new_char_start)
- isPal -> dfs (l: 1. dfs; 2. condi dfs*; 3. no dfs)
- start_func
- l: dfs start: 1. pt*; 2. str; 3. arr, etc
- motion:
- case 1:
- aba
- st: lo_path
- st: res (? push paths)
- at aba -> a (a; pal_*; p: [a]) OR ab (ab; pal_x) OR aba (aba; pal_*; p: [aba]; BT)
- at ba -> b (a; pal_*; p: [a, b] OR ba (ba; pal_x)
- at a -> (a; pal_*; p: [a, b, a], BT)
- 

- https://leetcode.com/discuss/interview-question/1625460/AMAZON-OA-Find-K-maximum-Priority


- https://leetcode.com/problems/factor-combinations (\*)
- complex:
- why dfs_n decrease, while dfs_curr increases?
- because dfs_n is being consumed by mod
- because dfs_curr in each dfs loop, dfs_curr inc, to pass down, to maintain inc order in result
- why dfs_n === 1 is the base case?
- because dfs_n is being consumed by mod
- why for i=curr; i <= dfs_n?
- i <= dfs_n, because dfs_n is being consumed and eventually === 1
- simple:
- res = [] (l: 1. g_track*; 2. init track; 3. level track)
- x
- dfs
- base_case (l: life reaches end, need highlight)
- path.len > 1 -> store res (l: 1. store res; 2. condi store res*; 3. no store res)
- base_case return (l: 1. re nothing*; 2. re overall bit/every; 3. re states
- loop num <= full_num (l: whatever sub: 1. dir; 2. edges .... 5. mod/divide (full_num inc consume)
- if dfs_n % i == 0 -> dfs (l: 1. dfs; 2. condi dfs; 3. no dfs)
- l: whatever can sub: 1. dir; 2. edges; 3. arr; 4. do/!do; 5. full_num inc consume
- path1 = paht.slice(0) (l: sub path === parallel universe)
- go dfs (l: whatever sub: ...)
- start_func
- dfs([], n, 2) (l: 1. whatever sub: 1. dir; 2. edges; 3. ... 5. full_num inc consume)
- res.sort (l: better looking)
- motion:
- case 1: 8
- st: lo_path
- st: res (push lo_path)
- 8 -> 2 (s = 2<= 8_*, %_*, 4_left, p: [2]), 3 (s_*, %_x), 4 (s_*, %_*, 2_left, s_x), 5 (s_*, %_x), 6 (s_*, %_x), 7 (s_*, %_x), 8 (s_*, %_*, 1_left, p: [8], but path.len >= 2_x)
- for 4 -> 2_* (p: [2, 2]); 3_x (%_x); 4_* ([2, 4]) 
- for 2 -> 1_* (p: [2, 2, 2]);
- for 1 (4_*'s, BT)

- https://leetcode.com/problems/palindrome-permutation (\*)
- complex;
- why aaabb, then a = 3 freq, b = 2 feq?
- because permutation, we can move around, for all orders
- why map.set(key), then map.delete(key)?
- beause map.size will reduce
- then map.size <= 1, means palindrome
- simple:
- l: side scrolling game, kill pair enemies, until single boss or no boss
- motion:
- case 1:
- bbbaaa
- b in, b out, b in; a in, a out, a in
- set {a, b}, not pal permutation

- https://leetcode.com/problems/palindrome-permutation-ii

- https://leetcode.com/problems/word-pattern-i (\*)
- complex:
- why str.split(' ')?
- because pattern === char by char
- because str === str_portion
- they are in sync match
- similar to word pattern ii's base_check
- pattern.len !== words.len, return false directly, shortcut
- map and seen (set) ignore map.get(pattern) === ws[i], why?
- because map and seen (set) only care pattern side
- must check map.get(pattern) === ws[i]
- word pattern 4 combos, what?
- 1. map === true and seen === true, and map.get(x) === ws[i], next iteration
- 2. map === true and seen === false, no sync match
- 3. map === false and seen === true, no sync match
- 4. map === false and seen === false, next iteration
- why?
- because based on word pattern ii
- why at the end of code, return true?
- because if nothing fails, then must be true, all match
- simple:
- l: try luck, shortcut
- pattern_loop
- l: map, set -> map; map, !set -> !possible; !map, set -> else_map; !map, !set -> remember
- end_pattern_loop (l: try everything fail, no way, re good)
- motion:
- case 1:
- prev_match, later reuse prev_match
- abba vs cat dog dog cat
- a -> cat (init set)
- b -> dog (init set)
- see b again, reuse
- case 2:
- prev_match, later mismatch
- abba vs cat dog dog fish
- a and b seen first, no more sset
- a -> fish, too late

- https://leetcode.com/problems/word-pattern-ii/ (\*)
- complex:
- what is p?
- p === entire pattern; pattern pair str_portion
- p_ind position in entire pattern
- what is s?
- s === entire string; pattern pair str_portion
- s_ind position in entire string
- what is map?
- map === pattern pair str_portion
- what is seen?
- seen === we seen this str_portion, we don't want to see this again
- what is the map set combo?
- 1. map.set(key, val) === key and val lock down relationship
- 2. we go through more inputs and find the same val
- 3. set saw this and reject immediately
- there are 2 ways to pass string into dfs?
- 1. pass entire string, use str_ind to position (this leetcode)
- 2. pass cut the string and pass necessary
- what is this base_check in dfs?
- p_ind === p.len && s_ind === s.len -> match
- p_ind !== p.len && s_ind === s.len -> !match
- p_ind === p.len && s_ind !== s.len -> !match
- p_ind !== p.len && s_ind !== s.len -> next code
- what is pattern[pattern_ind]?
- pattern[pattern_ind] === str_portion
- why use pattern[pattern_ind]?
- same pattern[pattern_ind] === str_portion
- if map has the pattern -> get str_portion
- do the shortcut, start from s_ind, then scan the str_portion, why?
- because shortcut
- 1. yes shortcut good, then return next dfs (directly)
- 2. no shortcut !good, then return false (directly)
- there are 2 ways to dfs
- 1. dfs === abstract
- 2. dfs has res within, after dfs done, res filled
- why p_ind+1?
- because pattern moves on
- why s_ind + tmp_sub.len? why not s_ind + tmp_sub.len+1?
- because s_ind already a fresh start, if +1 at the end, we overflow
- so s_ind + tmp_sub.len
- so we have 3 return in the dfs func
- 1. has pattern: shortcut, return
- 2. has pattern: !shortcut, return dfs
- 3. has !pattern: dfs === true, return true
- why?
- because if dfs === abstract, we must return
- if a loop within dfs === different dfs actions
- if 1 dfs action in the loop, success / false, return, why?
- because this is the pattern for dfs
- this (leetcode), diff dfs actions === s.substring(start_ind, i+1)
- try out diff str_portion
- why in the str_portion loop, we have if seen.has(str_portion) === true, continue?
- 1. because if we seen str_portion, map has it, we assume it works, so shortcut
- 2. code below map.set, seen.add, we don't want them operate
- so pattern happens again: global_seen.add -> dfs -> global_seen.del
- why pass to next dfs, p_ind+1, i+1?
- because p_ind+1, next pattern
- because i+1, 1 small step, next str_portion
- all done, nothing works return -1
- why there are 2 types global_seen.add -> dfs -> global_seen.del?
- 1. global_seen.add -> dfs -> global_seen.del
- 2. global_seen.add -> condi = dfs -> global_seen.del
- simple:
- const mp = new Map()
- l: g_seen (reset) === local_seen (no reset)
- l: map, set -> map; map, !set -> !possible; !map, set -> else map; !map, !set -> remember it
- l: map: separate one thing from other
- x
- const set = Set() (l: map do key, set do val*)
- x
- dfs
- base_case
- l: kid and adult reach end ATST
- l: kid reach 1st
- l: adult reach 1st
- curr_pat_char = pat[p_ind] (l: kid)
- if map (l: map, set -> map*; map, !set -> !possible*; !map, set -> else_map; !map, !set -> remember)
- l: kid and adult reach end, ATM -> next section
- l: kid or adult reach 1st -> entire waste
- x
- if !map (l: map, set -> map; map, !set -> !possible; !map, set -> else_map*; !map, !set -> remember*)
- in the_substr_loop (l: gen path: 1. dir; 2. edges; 3. arr; 4. do/!do; 5. brute_try*)
- in the_sub .. (l: map do the key, set do the val)
- mp.set
- set.add
- l: context this path
- condi = dfs (l: travel with this context)
- l: release this context, next branch new context
- l: 1. re nothing; 2. re overall bit*/every; re 3.states)
- end the_substr_loop (l: try every, fail)
- start_func (l: dfs start: 1. pt*; 2. arr; 3. str; 4. etc
- motion:
- case 1:
- prev_match, pattern re-appear
- aa vs ab
- a -> a pair lock
- a -> b fail directly; because map.get(a) === a
- case 2:
- prev_match, new pattern appear
- ab vs aa
- a -> a pair lock
- b -> a? seen (set) to skip a; why? because conditional dfs
- case 3:
- pattern far less than str_portion (random)
- ab vs xyjk
- a -> x pair lock
- b -> y (no)
- b -> yj (no)
- b -> yjk (yes)
- all three bs in str_portion loop, because greedy
- case 4:
- pattern far less than str_portion (pattern)
- aa vs xyxy
- a -> x pair lock
- a -> y? fail directly, in 1st if statement
- in str_portion loop, a -> xy, then shortcut a -> xy (another)

- https://leetcode.com/problems/flip-game-i (\*)
- complex:
- what is curr_state?
- curr_state === '++++', e.g.
- why in the curr_state loop, i < curr_state.len - 1?
- because we start at ind=0, we need to flip 2 char, so i=0 and i=1
- e.g. '++++' -> '--++'
- why check curr_state[i] === '+' && curr_state[i+1] === '+', in curr_state loop?
- because curr_state[i] and curr_state[i+1] are consecutive
- e.g. '++++' -> '--++'
- why we need to have curr_state loop to flip?
- because each flip === diff dfs action
- why before + '--' + after?
- because before + '--' + after, we flip them
- simple:
- loop: loop_str (? gen new state)
- op: str_concat (? gen new state)
- push_res
- motion:
- diff states in 1D loop
- case 1:
- flip ++ to --, each time in str
- ++++ -> flip
- i=0, i+1=1
- i=1, i+1=2
- i=2, i+1=3
- i=3 (no, as i < len-1 = 3)
- res = ['--++', '-++-', '++--']

- https://leetcode.com/problems/flip-game-ii (\*)
- complex:
- why no base_check?
- because curr_state from dfs func, got updated
- we have i=0 curr_state loop to re-check everything
- cs === overall current_state and pass from question func (cannot use in each dfs level)
- curr_state === current state after updated (can use in each dfs level)
- curr_ind === point to current str, we don't use as we start i=0, each dfs level
- this dfs === this player current move
- the curr_state loop is this player, the possible moves, that make next player false
- next dfs === next player move
- why this player i=0, in curr_state loop?
- because we don't know what the prev player done, need to re-check everything
- why before + '++' + after --> before + '--' + after?
- because this one of the move, dfs action
- it uses a trick:
- prev dfs level === prev player move
- this dfs level === this player move
- next dfs level === next player move
- summary it use diff dfs level to simulate diff people
- why current player want condi = dfs(new_state) === false?
- because if next player false, loose, then it means we will win, can return
- after the curr_state loop, we cannot beat next player, then we loose
- simple:
- dfs
- dfs_param (l: single var travel*; 2. var branch vars travel)
- loop(i=0; i<len-1...), flip 2 chars (l: 1. do 1 thing*; 2. do multi things)
- if + and + (l: 1. do 1 thing*; 2. do multi things)
- str + '++' + str (l: 1. do 1 thing*; 2. do multi things) 
- next_win = dfs(curr_state) (l: 1. single var travel*; 2. var branch vars travel)
- if next_win (l: 1. single var travel*; 2. var branch vars travel)
- end_dfs_loop (l: try every, fail)
- start_func
- l: try luck, shortcut
- l: dfs start: 1. pt; 2. str*; 3. arr, etc
- motion:
- case 1:
- flip ++ to --, each time in str
- p1 state: ++++
- p1 action: --++, +--+, ++-- (flip loop)
- p2 state (--++, e.g.)
- p2 action:
- --++, i=0, i=1, !++, con
- --++, i=1, i=2, !++, con
- --++, i=2, i=3, ---, good (dfs return feed back to p1)

- https://leetcode.com/problems/generalized-abbreviation (\*)
- complex
- e.g. ab, at ind = 0, we can take a or we an make counter = +1, so it represent a
- prev = prev + counter + curr
- what is prev?
- prev === prev dfs level, that prev + counter + curr
- what is counter?
- counter === 0,1,2,3, representing each letter and acc
- curr === str[curr_ind]
- now image the dfs tree for ab travel
- for state: we have these vars along it
- 1. prev = prev + counter + curr
- 2. counter
- 3. curr
- for action: we hvae these vars alongs it
- 1. prev = prev + counter + curr
- 2. counter
- 3. curr
- why state and action are same?
- because state and action both vars are changing, we need to keep track
- the change is prev and counter
- what is the change of prev and counter?
- if prev change (take), then counter need to reset
- if counter acc (!take), then prev stay the same
- either prev operates or counter operates, not both
- why str_ind >= str.length, we have these state
- 1. prev = prev + counter + curr
- 2. counter
- 3. curr
- 4. prev (res) = prev + coubnter + curr; we have no.4 extra, because we are at the end now, need to return
- why dfs bottom return is more important dfs go down?
- because for dfs, dfs bottom return is where all operation happening
- simple:
- res = [] (l: 1. g_track*; 2. init_track; 3. level_track)
- x
- dfs
- dfs param (l: travel buffer: prev* + buffer* + curr* + future)
- dfs param (l: keep track position in travel)
- base_case (l: life reaches end, need highlight)
- dfs (take) (l: gen paths: 1. dir; 2. edges; 3. arr; 4. do/!do*)
- dfs (!take) (l: gen paths: 1. dir; 2. edges; 3. arr; 4. do/!do*)
- start_func
- dfs(acc_str_'', 0_counter, 0+w_ind)
- l: dfs start: 1. pt; 2. str*; 3. num*; 4. arr, etc)
- l: travel buffer: prev* + buffer* + curr* + future
- motion:
- case 1:
- !take or take
- ab
- a -> 1 or a
- b -> 1 or b
- 1 and 1; 1 and b; a and 1; a and b
- 2, 1b, a1, ab

- https://leetcode.com/problems/android-unlock-patterns/ (x)
- https://medium.com/@rebeccahezhang/leetcode-351-android-unlock-patterns-d9bae4a8a958 (x)
- https://massivealgorithms.blogspot.com/2016/06/leetcode-351-android-unlock-patterns.html (x)
- https://cheonhyangzhang.gitbooks.io/leetcode-solutions/content/351-android-unlock-patterns.html (x)

- https://leetcode.com/problems/robot-room-cleaner/, https://wentao-shao.gitbook.io/leetcode/graph-search/489.robot-room-cleaner (\*)
- complex:
- why 4 dir?
- because robot movement in 4 directions
- mine sweeper (leetcode) has 8 directions
- why need seen for robot movement?
- prev map.set(cell_index, true), so have visited this cell -> map.has(cell_index) === true
- map.has(cell_index) === true -> avoid visit again, avoid loop
- what is curr_dir?
- curr_dir === prev_i
- curr_dir === 0,1,2,3,4,5,etc; it is not really the direction robot heading
- it is index to access [[0, -1], [0, 1], [1, 0], [0, -1]];
- we can see that curr_dir overflow, so curr_dir % 4, to avoid overflow
- in the dfs param, why we need curr_dir combo with (curr_row, curr_col)?
- having curr_row and curr_col we know which cell we land
- having curr_dir we know on this cell, which direction heading to, hence affect next dfs move directly
- 1. clean cell (actual operation)
- why clean cell on top of dfs?
- because when code come from param, we have done all the future check
- so now it is safe to do operation
- 2. set seen (avoid loop)
- why set seen on top of dfs?
- because when code come from param, we have not seen it, but when come to this dfs level, we need to set seen, to avoid loop
- why (curr_i + i) % 4?
- curr_i = 0,1,2,3,4,5; not really direction, but index to access dir arr
- curr_i + i === prev_i + curr_i
- (curr_i + i) % 4; curr_i overfow, %4 to avoid overflow
- why we need conditional dfs?
- because we cannot just dfs, travel the whole trees; pick the dfs path relevant
- map.has(cell_index) === true -> no dfs
- map.has(cell_index) === false -> may dfs
- ro.move() === true, can dfs
- ro.move() === false, no dfs (hit obstacle / boundary)
- why map.has(cell_index) && ro.move(), map.has before ro.move?
- because ro.move() is the physical movement to detect hit obstacle / boundary
- why r -> r -> ro.move -> r -> r?
- because map.has(cell_index) && ro.move(), we have ro.move() in condition
- it is a physical check, so need to revert it, so ro.move()
- why after the dfs (or no dfs), we need to turnRight?
- whether prev dfs (or no dfs), we still need to head to next direction
- why there is no loop -> dfs; why direct dfs?
- because there are loop at all
- why start as dfs(0, 0, 0)?
- dir = 0, row=0, col=0; that is how we start
- simple:
- g_seen: map.set (? cell cleaned, not more clean)
- op: ro.clean (? all good, clean operation)
- dfs_4_dir_loop: 4_dir (? robot needs to move)
- mod_index: new_dir_index (? so constraint under 4_dir arr, pick 1 only)
- future: future_cell (? future move)
- future_check: check future (? !seen + can_move)
- steal: ro.move (? actual move)
- dfs_4_dir_iteration: dfs (? after_check all good, op)
- revert: R -> R -> move -> R -> R(? check_future, has actual move)
- move_on: turnRight (? move on next)
- motion:
- robot on 2D grid (backtrack)
- robot (robot.move()) has move / dir, 'v-dom' (the code) has move / dir
- robot move / dir at the end of dfs (curr), 'v-dom' move / dir on top of dfs (next)
- for init new_dir (this dfs level), i = 0, new_dir can use directly (no effect curr_dir)
- curr_dir !matter; i larger and larger, new_dir turn big
- after dfs return, that cell pickes up what is left, continue there
- when pick up left finish (this dfs level, 4 dir loop)
- robot steps back to prev, will pick what is left (prev dfs level)
- turnRight === real turn right, future turn right === no real turn right


- https://leetcode.com/problems/campus-bikes-ii/ (\*)
- complex
- why min = +Infinity?
- because we need to assign smaller number, +Infinity can definitely get things going
- why I need a global_seen?
- because bike_ind = 0 always as start in dfs loop, so global_seen[bike_ind] === true, avoid hit again
- global_seen[bike].add -> dfs -> global_seen[bike].del, for worker stable, bike loop
- why we need a 2D rem arr, init with -1?
- actually, we don't need them
- because there is code blow if rem[worker_ind][bike_ind] === -1, rem[worker_ind][bike_ind] = tmp_dist
- this is the only time we update rem[worker_ind][bike_ind]
- then dfs(this_dist + rem[worker_ind][bike_ind], worker_ind)
- it is same as this_dist + tmp_dist
- so we don't need rem[worker_ind][bike_ind]
- what is manhattan distance?
- manhattan_distnace = abs(x2-x1) + abs(y2-y1)
- similar to c^2 = a^2 + b^2
- on top of dfs, why tmp_dist >= min, early return?
- because it is shortcut, tmp_dist >= min, no use
- on top of dfs, why worker_ind >= ws.len, return min = min(min, xxx)
- because worker_ind finish
- why we loop bike?
- because it is a bike stable
- on top of dfs, why global_seen[bike_ind] === true?
- because bike_ind always starts at 0 again.
- why global_seen[bike_ind].add -> dfs -> global_seen[bike_ind].del?
- because 2 ways to use global_seen?
- 1. global_seen.add
- 2. global_seen.add -> dfs -> global_seen.del (why del? for next iteration's branch)
- why we cannot loop (worker) -> dfs (bike)?
- because this (leetcode) is like first_player_win_flip_game (leetcode)
- player 1 and player 2 switch ~= worker and bike swich
- so dfs directly
- simple:
- min = inf (l: 1. g_track*; 2. init track; 3. level track)
- g_seen = arr[bike.len]
- l: occupy -> this branch -> unoccupy -> next branch
- l: worker === row (func param), bike === col (func body loop)
- cal = func (l: 1. 1D dist*; 2. 2D dist)
- dfs = func(tmp_dist...) (l: acc dist in travel, until end)
- if tmp_dist >= min 
- l: curr interview (waste effort)
- within re (l: 1. re nothing*; 2. re overall ....)
- x
- if worker >= ws.len
- l: curr interview (outbound)
- l: acc dist in travel, until end
- x
- bike loop
- l: worker === row (func param), bike === col (func body loop)
- l: future interview (avoid same)
- g_seen[x] = true
- l: future offer, occupy* -> this branch -> unoccupy -> next branch
- l: g_seen (reset) === local_seen (no reset)
- x
- dfs(dist.., worker+1)
- l: next candidate (occupy -> this branch* -> unoccupy -> next branch)
- l: acc dist until end
- g_seen[x] = false (l: occupy -> this branch -> unoccupy* -> next branch)
- start_func
- dfs(0, 0)
- l: dfs start: 1. pt*; 2. arr; 3. str, etc
- l: overall greedy, no matter who 1st
- motion:
- case 1:
- ele in arr, in each dfs, then repeat loop the other arr
- worker: [[0, 0], [1, 1]]
- bike: [[2, 2], [3, 3]]
- [0, 0] in this dfs level, loop [2, 2], [3, 3]
- next dfs level [1, 1], loop [2, 2], [3, 3], with g_seen


- https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/ (\*)
- complex:
- what is 1 and 0?
- 1 === block
- 0 === empty_path
- what is g?
- g === 2D grid with 0 and 1
- what is k?
- k === how much we can convert block to empty_path
- what is res?
- we start from (0, 0) to (m-1, n-1), how many steps
- what is this data structure?
- [row, col, k_so_far]
- normally is [row, col], but we have k here
- q = [[0, 0, 0]], why we init queue with single element?
- because while(q.len > 0), queue can start; q = [], queue cannot start
- why we need a global_seen?
- because we travel from (0, 0) to (m-1, n-1) in a 2D grid; k just extra
- why we need a 3D grid?
- because [row, col] this is normal, k extra -> [row, col, k_so_far]
- why global_seen[r][c][k+1], why k+1?
- because 0,1,2,3,4...; there are k+1 elements
- why global_seen[r][c][k_so_far] === true / false?
- because seen and !seen
- why normnally we need to init all data structure?
- 1. grid[r][c]
- 2. queue[r][c][k], init
- 3. global_seen[r][c][k], init
- because if we don't init, the process cannot start
- why these 3 data structure are very similar?
- because they are origin from grid[r][c], k just extra
- why the entire flow like this?
- queue_check -> dequeue -> 4_dir -> push_queue -> queue_check
- 1. queue_check === because we dequeue and push_queue, we don't know when finish; breadth level
- 2. dequeue === q.shift(), so the queue can eventually stop
- 3. 4_dir === (the future_row = row + row_d pattern)
- 4. push_queue === exhaust breadth level
- 5. queue_check === back to where we start
- what is loop(i=0; i<q.len; ++i)?
- loop(i=0; ...) === breadth level exhausting
- why future_row = row + row_d is the 4_dir dedicated pattern?
- because 
- future_row = row + row_id; future_col = col + col_d
- why put end check under queue_loop?
- because this is the 1st time we have row and col
- in the 4 dir loop,
- 1. boundary?
- 2. end point?
- 3. can dfs? (use k and !seen)
- (1) is it boundary?
- yes: continue
- no: next code
- (2) is it end point?
- yes: return res+1 (future point)
- no: next code
- (3) can dfs? (use k and !seen)
- why we cannot just dfs? why we need to put more condi to dfs?
- normally we don't travel the full dfs, we only go to certain dfs path
- why we put next_k = curr_k + 1 within the 4_dir loop?
- why not put next_k = curr_k + 1 before 4_dir loop?
- because put before 4_dir loop, next_k will be the same and will be updated in each iteration
- but it within 4_dir, will always use same curr_k+1, in each iteration
- summary, a var before loop, will keep updated; a var within loop, will stay same each iteration 
- what is use the k?
- 1. g[r][c] === 1, it is block -> next_k = curr_k + 1;
- 2. g[r][c] === 0, empty_path -> next_k = curr_k;
- what is seen and !seen?
- 1. seen === global_seen[r][c][k_so_far] = true, no dfs
- 2. !seen === global_seen[r][c][k_so_far] = false, dfs
- why put ++res after queue_loop?
- because queue_loop finish === breadth level scan finish, ++res
- why put return -1 after queue_check?
- because the overall breadth levels finish within queue_check
- if(r === m-1 && c === n-1) return res;
- if we cannot return within queue_check, then nothing more we can do, return -1
- simple:
- l: go down / go right
- g_seen (3D) (l: 2D board, extend 1 extra D, hold stuff)
- g_seen[0][0][0] ... (l: buy a machine, warm up)
- q = [[0, 0, 0]] (l: buy a machine, warm up)
- dir = [..] (l: 1. 4 dir*; 2. 8 dir)
- res = 0 
- l: 1. g_track* (step); 2. init track; 3. level track
- l: bfs: own range (res) -> next range
- l: dfs: own branch (res) -> next branch
- while(q.len > 0) (l: queue: put into box, take out, process)
- size = q.len (l: bfs: own range (res) -> next range)
- loop (q.size), q.shift (l: queue: put into box, take out, process)
- loop 4 dir (l: parallel universes, effect in 1 universe, no effect in other universes)
- within_4_dir_loop, next_k = curr_k (l: parallel universes, effect in 1, no effect in others)
- up, down, left, right (l: interview (outbound))
- block, then use k (l: inteview (have diffculty, use help))
- next_k = curr_k+1 (l: parallel universes, effect in 1, no effect in others)
- g_seen[][][] (l: interview (seen)
- l: during long travel, found treature, go home
- l: offer (avoid same)
- l: offer (push queue)
- x
- l: 1. dfs; 2. condi dfs; 3. no dfs
- l: 1. queue*; 2. condi queue; 3. no queue
- end own range queue loop, ++res
- l: bfs: own range (res) -> next range
- l: dfs: own branch (res) -> next branch
- end_entire_queue, re -1 (l: try everything, fail)
- motion:
- case 1:
- at start -> 4_dir, push right and down
- grid: [[0, 1], [0, 0]]
- start as [0, 0, 0]
- at (0, 0) -> 4-dir ; up bad no push; right good push to queue; down good push to queue; left bad no push
- queue = [[right], [down]]
- consume [right] -> 4_dir

- https://leetcode.com/problems/brace-expansion/ (\*)
- complex:
- why base check, ind >= str.len, then res.push(path)?
- because ind scan from left to right, end of str, now push result
- when res.push(path.join('')), why we need path.join('')?
- because path === [a,b,c], path.join('') === abc; we need string, not arr
- if(s[ind] === '{') and if(ind === '{'), why they are diff?
- s[ind] === actual char
- ind === the index, so diff
- why there are 2 dfs paths?
- e.g. a{b,c}
- 1. path1: a
- 2. path2: {b,c} -> it can become path2.1, b and path2.2, c
- why we need to scan { and }?
- because {a,b,c} -> [a, b, c] -> 3 dfs paths
- why there are 2 ways to copy dfs path?
- 1. path.push -> dfs -> path.pop; single path
- 2. path.slice(0) -> path1.push -> dfs; copy path
- simple:
- res = []; (l: 1. g_track*; 2. init track; 3. level track)
- x
- dfs
- base case (l: time (ind) all the way, hit end, highlight)
- res.push path (l: time ..., hit end, hightlight)
- life:
- l: 1. either hit corss road (new decision = copy orig decision + curr decision)
- l: 2. or straight road
- start_dfs
- dfs([], 0) (l: dfs start: 1. arr*; 2. pt; 3. ind*; 4. str, etc)
- l: new deci = copy + curr deci
- motion:
- a{b,c}d -> a single path, {b,c} 2 paths, d single path


- https://leetcode.com/problems/stepping-numbers/ (\*)
- complex:
- if lo === 0, res.push(0), why?
- because outerloop i=1 -> i=9, we don't want i=0
- why we don't have if hi === 0, res.push(0)
- lo === 0, res.push(0), enough, why need hi === 0, res.push(0)
- 
- on top of dfs, why curr > hi, return directly?
- because we need hi >= curr >= lo, curr > hi, out of range
- why hi >= curr >= lo, res.push(curr), why no return?
- because curr can gen more prev and next
- why res.push(curr), why curr has no repeated?
- because i=1 -> i=9, i is diff
- 
- why use curr to get last_digit?
- because (curr) and (curr % 10 - 1) are step number, desc releated
- curr*10 === left num; last_digit-1 === right num
- because (curr) and (curr % 10 + 1) are step number, inc related
- curr*10 === left num; last_digit+1 === right num
-
- why if last_digit > 0?
- because prev === next_curr in next dfs, it gets less and less, so last_digit > 0, keep it under control
- why last_digit === 0, cannot use?
- because e.g. prev = curr(0)*10 + last_digit(0) - 1 -> 0 + 0 - 1 -> -1 (not step number)
- why not curr > 0 -> dfs(prev)?
- because curr === 100, 99999, 1000000 very large num
- we want last_digit under control < 0
- similar why not curr < 9 -> dfs(next)
-
- why if last_digit < 9?
- beause next === next_curr in next dfs, it gets more and more, so last_digit < 9, keep it under control
- why last_digit === 0, cannot use?
- because e.g. next = curr(9)*10 + last_digit(9) + 1 -> 90 + 10 -> 100 (not step number)
- 
- why we finish dfs(prev) -> dfs(next)?
- because exhaust prev, until last_digit <=0, -> dfs(next)
- beause exhaust next, until last_digit >= 9, -> out of this func
-
- why outerloop i = 1 -> i = 9?
- why there is no i = 0?
- because i=0, handle by res.push(0)
- we don't want zero, e.g. prev = curr(0)*10 + last_digit(0) - 1 --> -1
- simple:
- dfs = func(...., curr) (l: travel with belongings)
- if curr > hi re; curr >= lo (l: result must in bound)
- last_num = curr % 10 (l: 1. get left nums; 2. get last nums*)
- prev = curr*10 + last-1 (l: left # and right # have relationship)
- next = curr*10 + last+1 (l: left # and right # has relationship)
- if last > 0 -> dfs (l: 1. dfs; 2. condi dfs*; 3. no dfs)
- last = 0, prev = -1 (l: ele before bound, next cannot)
- if last < 9 -> dfs (l: 1. dfs; 2. condi dfs*; 3. no dfs)
- if last = 9, next = 10 (l: ele before bound, next cannot)
- start_orig_func
- res = [] (l: 1. g_track*; 2. init track; 3. level track)
- lo === 0 -> res.push(0) (l: num cannot start with 0)
- loop (i=1.. i<9..) 
- l: num cannot start with 0
- l: 1. start small cascading big*; 2. star big cascading small
- re res.sort (l: better looking)
- motion:
- 0 -> prev = curr(0) * 10 + last(0 % 10) - 1 -> no good
- 0 -> next = curr(0) * 10 + last(0 % 10) + 1 -> no good
- so 0 special handle, res.push(0)
- natural flow loop:
- 1, res.push(1), single digit === step num; prev = 10 and next = 12
- 2 -> 21 and 23
- 3 -> 32 and 34
- 4 -> 43 and 45
- 5 -> 54 and 56
- 6 -> 65 and 67
- 7 -> 76 and 78
- 8 -> 87 and 89
- 9 -> 98 and 90(9 cannot use, as no next num)
- prev -> curr = 10 -> last_digit = 0 -> curr(10) * 10 + last(0) - 1 -> 100 - 1 = 99, no step num, no good -> last_digit > 0
- next -> curr = 9 -> last_digt = 9 -> curr(9) * 10 + last(9) + 1 -> 90 + 10 -> 100, no step num, no good -> last_digit < 9
- rest can dfs_correct_last_digit_action 

- https://leetcode.com/problems/synonymous-sentences/ (\*)
- complex:
- what is connect?
- [happy, joy]: happy -> joy
- or [happy, joy]: joy -> happy
- so 2 directions, forward and backward
- why 2 directions?
- [happy, joy]: happy -> joy, joy -> happy
- in graph, why the entry is hash, but the val is arr?
- because hash key === word, value === arr, allow easier to assign elements
- why we need to check graph[w1] === undef and graph[w1] === undef?
- 1. graph[w1] === undef, then graph[w1] === empty
- 2. graph[w1] !== undef, then graph[w1] === arr_with_element
- why loop sync?
- sync === [['a', 'b'], ['c', 'd']]
- e1 === ['a', 'b']; a, b connect
- e2 === ['c', 'd']; c, d connect
- why we need a queue here?
- the init queue is not empty, the while loop can consume it
- if the queue is empty, we cannot continue the rest of operations
- q = [str], we can start dequeue and process
- e.g. same 2D arr dp, with init, longest distance in 2D grid
- why we push entire str into init_queue_arr, const q = [str]?
- because queue_loop -> str -> word_arr -> edges
- why we need a global_seen here?
- because it is a graph, also it is bi-directions
- it is very easy to get into loop, in graph
- why g_seen.add has to be before loop?
- because if the actual operation within loop and if loop is empty, then actual operation is not reachable
- why we have 3 loops here?
- 1. str_queue loop ([str])
- 2. word loop (str -> word_arr)
- 3. edge loop (word -> edges)
- why we use while loop to loop queue?
- most of the time, we use while loop to consume queue
- because we don't know when it is finish
- also we will push elements into it, in while loop
- why we need to dequeue and get the str out?
- because the queue size will change (str = q.shift()) and while loop eventually stop (while(q.len > 0))
- in word_arr loop, graph[w] === undef, then continue, why?
- str -> word_arr, e.g. I and am, it is not in sync at all
- graph['I'] or graph['am'] has no entry, so graph[w1] === undef, continue
- we have word (vertex) -> replaced words (edges), why?
- because this what the sync for
- after graph[w] === undef, fail condi; then we enter graph[w] !== undef
- that means edges = graph[w], why?
- because graph[w] === undef -> empty; graph[w] !== undef -> have edges
- why word_arr[i] = replaced_word?
- because [joy, happy]: joy -> happy, happy -> joy
- also word_arr.join(' ') will form new string with replaced word
- why !global_seen.has(new_str) -> we push to queue.push(new_str)?
- if we seen it globally, then we must not process by adding to the queue
- why we don't do global_seen.add(new_str), after !global_seen.has check?
- because we follow natural flow, check on top of dfs
- simple:
- l: graph: relationship to other or relationship to self
- l: b(g)
- word1 -> word2, word2 -> word1 (l: word can exchange)
- const q = [str]
- l: 1. dfs; 2. bfs*
- l: queue must has something to process
- g_seen (l: avoid same)
- while (q.len > 0) (l: queue must has something to process)
- q.shift() (l: queue must has something to process)
- within_queue_loop
- g_seen.has... (l: interview (avoid same))
- arr = sentense.split (l: sentense contains words)
- if(graph[w] === undef) (l: some vertex has edges; some vertex no edges)
- l: gen paths: 1. dir; 2. edges*; 3. arr; 4. inc num, etc
- in_edge_loop, arr[i] = e (l: can physicall replace, as prev stored in queue; word multi exchange)
- l: 1. push queue; 2. condi push queue*; 3. no push queue
- l: 1. dfs; 2. condi dfs*; 3. no dfs
- motion:
- case 1:
- 2 cycles, 1 interception
- sync: [happy, joy], [joy, cheerful]
- sen: I am happy .....
- graph: happy and joy cycle; joy and cheerful cycle; 1 interception
- I am happy -> [I am happy] -> [I, am, happy] -> [I, am, joy] -> I am joy -> [I am joy] -> [I, am, joy] -> [I, am, happy] (x, g_seen) and [I, am, cheerful] -> [I am cheerful] -> [I, am, cheerful] -> [I, am, joy] (x, g_seen)
- int_str -> queue -> word_loop -> sync (replaced) -> str -> queue
- case 2:
- 2 cycles, 2 branches
- sync: [happy, joy], [happy, cheerful]
- sen: I am happy
- graph: happy and joy cycle; happy and cheerful cycle; 2 branches
- I am happy .. -> [I am happy] -> [I, am, happy] -> [I, am, joy] and [I, am, cheerful] -> [I am joy, I am cheerful] -> [I am joy] -> [I, am, joy] -> [I, am, happy], g_seen(x) -> [I am cheerful] -> [I, am, cheerful], g_seen(x)
- case 3:
- 2 cycles, repeated
- sync: [happy, joy], [joy, happy]
- sen: I am happy...
- graph: happy and joy cylce; repeated
- I am happy.. -> [I am happy..] -> [I, am, happy,..] -> [I, am, joy] -> I am joy .. -> [I am joy...] -> [I, am, joy..] -> g_seen(x)


- https://leetcode.com/problems/maximum-number-of-accepted-invitations/ (\*)
- complex:
- why row len === boy?
- because boy in row
- the single boy invite girl
- why col len === girl?
- because girl in col
- why there are 3 data structure?
- global_match === global girl boy matching state
- local_seen === this boy, this dfs
- grid[boy_ind][girl_ind] === can invite girl or not
- why use local_seen for each dfs travel?
- because outerloop -> dfs
- why use 1D arr for global_match and local_seen?
- because the ind === girl, value === boy; 1D arr is enough
- why all girl slot set to false?
- seen === true, !seen === false
- why we use n (girl_ind) as arr_len?
- why not use m (boy_ind) as arr_len?
- because e.g. there are many girls, not enough boys, so there are empty girl slot
- there are not enough girls, too many boys, so the girls are full
- why global_match[girl_ind] = boy_ind has to be global?
- because global_match[girl_ind] ~= global_seen, it holds the entire state of matching
- why not use global_match[boy_ind] = girl_ind?
- no beause local_seen[girl_ind] and global_match[girl_ind], they have consistent format
- why use -1 for the global_match?
- 1. global_match[girl_ind] === -1 (still in init stage)
- 2. globa_match[girl_ind] === boy_ind (already assigned)
- why there is no base check here, on top of dfs?
- we have global_match and local_seen checking within girl loop
- boy_ind cannot assigin into global_match[boy_ind], local_seen[boy_ind]
- why loop girls in dfs?
- because boy invites girl, in outerloop
- now girl loop in dfs
- boy_ind passed as param, stable, girl_ind loop
- why girl_ind starts at 0?
- because the dfs param, curr_boy_ind or prev_boy_ind, we loop the girl from start
- so we can re-do all girls for boys
- in the girl loop:
- 1. can we invite a girl? (most obvious)
- yes, g[boy_ind][girl_ind] === 1, next condi check
- no, g[boy_ind][girl_ind] === 0, next iteration
- 2. have we seen this girl? (most obvious)
- yes, seen this girl in this dfs, next ieration
- no, have not seen this girl in this dfs, next condi check
- 3. can we assign this boy to this girl? (assign)
- yes, global_match and local_seen assign, out directly, because ++res
- no, we cannot assign global_match and local_seen, next code (switch global_match)
- why we get out directly?
- because we don't want to switch global_match
- also condi === true, ++res
- why local_seen[girl_ind] = true, before dfs?
- because local_seen[girl_ind] = true ~= block after all checks
- if we don't seen now, go to dfs, we will hit this girl again, in same dfs
- 4. so current entire matching state is no good, can we change the entire matching state, 1 by 1
- why dfs(global_match[girl_ind] === prev_boy_ind) is called switch?
- because global_match[girl_ind] === prev_boy_ind
- so we restart from prev_boy_ind and redo from there
- if can_switch -> global_match assign -> local_seen assign -> return true
- why return false should after girl loop?
- because we put within girl loop, just return and skip many iterations
- normally return true after girl loop
- simple:
- l: go down / go right
- l: local_mem and g_mem
- l: 2D -> 1D dp arr; ind for one thing, val for another thing
- x
- dfs
- loop girls (l: 2D ~= brute force)
- l: interview (something valid?)
- l: interview (in local mem?)
- l: offer (g_mem not use, use it)
- re directly (l: 1. re nothing; 2. re overall bit/every*; 3. states)
- l: offer (g_mem use, remember in local mem)
- l: offer (g_mem use, switch g_mem)
- l: offer (switch done? need outcome)
- end girl loop (l: try every, fail)
- x
- start boy loop
- res = 0 (l: 1. g_track*; 2. init track; ...)
- boy_loop
- l: local_mem, g_mem
- info var (l: when travel, belongings)
- motion:
- grid: [[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]
- local_seen: [f, f, f] (index === girl_ind, val === boy_true_false)
- g_seen: [-1, -1, -1] (index === girl_ind, val === boy_ind
- bi = 0, gi = 0 (*)
- bi = 1, gi = 0 (x) -> (brother force) bi = 0, gi = 0 -> (switch) bi = 0, gi = 1 (*) -> (backtrack) bi = 1, gi = 0 (*)
- bi = 2, gi = 0 (x) -> (b-f) bi = 1, gi = 0 -> (switch) bi = 1, gi = 1 (x) -> (b-f) bi = 0, gi = 1 -> (switch) bi = 0, gi = 2 (*) -> (b-t) bi = 1, gi = 1 (*) -> bi = 2, gi = 0 (*)

- https://leetcode.com/problems/minimum-number-of-lines-to-cover-points/ (\*)
- complex:
- why need pt1?
- because cal_slope(pt1, pt2)
- why need pt2?
- because cal_slope(pt1, pt2)
- why we need to care point 1 === point 2?
- pt1 === pt2, large infinity slope, not usable
- pt1 !== pt2, we have slope to use, usable
- on top of dfs
- 1. have we exhausted all pt_arr?
- pt_arr.len === 0, return line.len
- pt_arr.len !== 0, we need to use existing line_arr to cover
- why use line_arr to cover first pt?
- why not cover last pt?
- possible we can, but use 1st pt
- yes can cover first pt -> line_arr loop -> compare_slope -> return dfs(pt_arr_1_less, line_arr)
- no cannot cover first pt -> loop pt_arr -> form new slope -> dfs(pt_arr_i_less, line_arr_inc)
- 2. no we have some ele in pt_arr; loop line_arr -> compare_slope -> dfs(pt_arr_1_less, line_arr)
- why first_slope === curr_pt_slope -> return dfs(pt_arr_l_less, line_arr)?
- why we need to return?
- if no return, we stay in pt_arr loop; after loop finish, we enter pt_arr, which we don't want
- line_arr cannot cover first pt
- we have a shortcut: if pts.len === 1, return line.len + 1, why?
- because shortcut
- why this also an early return?
- because same reason, we don't want to enter pt_arr loop
- why min line to cover 1st pt?
- because min = dfs(pt_arr_i_less, line_arr_inc)
- each iteration of pt_ar === 1 dfs decision
- 3. line_arr loop: line_arr cannot cover 1st pt, loop pt_arr -> form new slope -> dfs(pt_arr_i_less, line_arr_inc)
- pt_arr_i_less === pt_arr remove i
- line_arr_inc === line_arr.push([pt_i, pt_i_slope])
- why line_arr.push pt_i, not first_pt?
- because pt_arr we remove pt_i, line_arr, we inject pt_i
- simple:
- cal_func
- 1. 1D dist (manhattan); 2. 2D dist (physical)*
- if x2 == x1, slope == inf (l: life lies down easier)
- x
- dfs
- base_case, pts.len == 0 (l: task done, reduce task)
- l: list of task: 1. do 1st*; 2. do mid; 3. do last
- lines can cover? (l: use existing power, can solve?)
- l: 1. [p1, p2] (harder); 2. [p1, slope] (easier)*
- if tmp_slope == slope, pts.slice(1) (l: task done, reduce task)
- if pts.len == 1 (l: task done, reduce task; shortcut for 1pt)
- min = inf 
- l: before dfs: 1. min/max*; 2. acc
- l: diff path to solve, result diff
- l: 1. g_track; 2. init_track; 3. level track*
- loop pts (l: existing power not enough, ask help)
- l: gen path: 1. dir; 2. edges; 3. arr*; 4. inc num, etc
- start_func (l: 1. pt; 2. str; 3. str, etc)
- motion:
- pt: [0, 2], [-2, -2], [1,4]
- line: []
- end_check (x)
- dfs_line (x)
- shortcut (x)
- dfs_pt (*)
- 
- pt: [0, 2]_1st_pt, [-2, -2], [1, 4]
- line: []
- (1) take [-2, -2]; [-2, -2] cover [0, 2]
- 
- pt: [0, 2], [1, 4]
- line: [-2, -2], 2
- ec (x)
- dfs_line (*)
- sc (x)
- dfs_pt (x)
- take [0, 2]; [-2, -2], 2 cover [0,2]
- 
- pt: [1, 4]
- line: [-2, -2], 2
- ec (x)
- dfs_line (*)
- sc (x)
- dfs_pt (x)
- take [1,4]; [-2, -2], 2 cover [1, 4]
- 
- pt: []
- line: [-2, -2], 2
- return line.len === 1 (min)
- 
- (2) take [1, 4]; [1, 4] cover [0, 2]
- 
- pt: [0, 2], [-2, -2]
- line: [1, 4], 2
- ec (x)
- dfs_line (*)
- sc (x)
- dfs_pt (x)
- take [0, 2]; [1, 4], 2 cover [0,2]
-
- pt: [-2, -2]
- line: [1, 4], 2
- ec (x)
- dfs_line (*)
- sc (x)
- dfs_pt (x)
- take [-2, -2]; [1, 4], 2 cover [-2, -2]
- x
- pt: []
- line: [1, 4], 2
- return line.len === 1 (min)

- https://leetcode.com/problems/nested-list-weight-sum (\*)
- complex:
- why we pass arr and depth as param in dfs?
- because arr === branch
- because or arr === leaf
- arr is changed in each dfs level
- why arr is changed, because into each dfs level, arr is diff
- why we need depth?
- because sum = sum + ele.getInt() * depth (here)
- why we have a res before the arr loop?
- e.g. [1, 1], 2, [1, 1]
- [1, 1] === sub result
- 2 === sub result
- [1, 1] === sub result
- why we loop arr?
- e1 === [1, 1], e2 === 2, e3 === [1, 1]
- so it can be leaf or it can be branch
- here, we have 3 decisions
- in arr loop, ele = arr[i], why ele can be leaf or branch?
- [1, 1] === branch; 2 === leaf
- why res is acc?
- sum1 = [1, 1], sum2 = 2, sum3 = [1, 1], add up together
- so res = res (prev sum1, sum2) + sum3
- why pass arr and depth + 1 for next dfs level?
- because pass arr, we can get arr === leaf or branch
- depth+1 is for next level, res = res + getInt() * depth
- simple:
- see weight sum ii
- motion:
- case 1:
- [1, [4, [6]]; depth = 0 (? because started)
- depth 1:
- action: 1 (int); depth = 1; end
- action: [4, [6]] (arr); depth = 2
- [4, [6]]; depth = 2
- action: 4 (int); depth = 2; end
- action: [6] (arr); depth = 2
- [6]; depth = 2
- action: 6 (int); depth = 3; end
- backtrack: 6 * 3 (depth) = 18, etc..


- https://leetcode.com/problems/nested-list-weight-sum-ii (\*)
- complex:
- why max depth === 1?; dep
- why not max depth === 0, because [[]], this maxDepth === 0?
- the test case so far is [1, []], 1 <= list.len <= 50, so at least 1 ele
- so max depth === 1
- why we cannot put max = max(max, curr_depth) outside of dfs loop?
- beacuse [[[]]] === no_init === no_depth
- if put outside of dfs loop, it will count the depth
- why [1, []] this depth === 1, not 2??????
- because e1 === 1 (depth === 1), e2 === [] (dfs will go down, we don't know the depth yet)
- e2 === [], into the next dfs level, there is a loop, but update the depth is within loop
- [] cannot get into loop -> cannot update depth, so depth === 1 (for e1)
- it is a leaf (end) and branch (arr)
- ele.isInteger() !== ele.getInteger() 
- ele.isInteger() --> is it an int, checking
- ele.getInteger() --> return int, actual thing
- why maxDepth is the global, not within dfs?
- because maxDepth needs to be stable, and maintained
- if put maxDepth within dfs, it will overwrite
- if ele.isInt() -> max(maxDepth, depth), why I need to compare depth, even 
- when ele.isInt() is there, e.g. [e1, e2, e3], so we never get into the else to dfs
- so we need max(maxDepth, depth) to update maxDepth
- for curr_arr loop, 
- all the ele * weight and dfs are within loop
- curr_arr.len === 0, no loop, will not get into ele * weight / dfs, no update depth
- why we don't do dfs(ele.getList(), depth + 1) * weight?
- dfs(ele.getList(), depth+1) === all elements result (weight for single element), if all_elements_result * weight, nono
- simple:
- maxLen = -1 (l: 1. g_track*; 2. init_track; 3. level_track)
- x
- dfs_get_max_depth
- param depth (l: info var along dfs)
- loop curr_arr
- l: life has many paths
- l: sub problem, eaiser
- l: gen path: 1. dir; 2. edges; 3. arr; 4. inc num, etc
- if int else dfs_get_max_depth
- l: life reaches end, need change
- l: life can keep going
- in_loop (l: remember the best moment)
- end (l: 1. re nothing*; 2. re overall....)
- x
- depth = get_max_depth (l: find the best moment)
- x
- dfs to cal val
- sum = 0;
- l: 1. g_track; 2. init track; 3. level track*
- l: 1. acc*; 2. max/min
- l: 1. re nothing; 2. re overall (bit or every*); 3. re states
- loop curr_arr
- l: life has many paths
- l: sub problem easier
- l: gen path: 1. dir; 2. edges; 3. arr; 4. inc num
- if int else
- l: life reach end, change
- l: life keeps going
- start_func
- l: 1. dfs has start pt; 2. dfs has str; 3. dfs has arr* ..
- motion:
- dfs_init_arr_loop

- https://leetcode.com/problems/different-ways-to-add-parentheses/ (\*)
- complex:
- why given str, then directly dfs?
- given str (start dfs level), then put diff brackets (diff brackets -> diff dfs sub path)
- why we need a global map?
- key: str, val: [e1, e2]
- because we cache / dfs
- what is str param passed down?
- e.g. 2-1-1; 2-1; 1
- it is always full cal form, never has -2 or 2-
- because we split +, -, *, left out === full cal form
- why we don't have a base check?
- res is like the base check
- 1. res = [] -> str is num -> [str_num]
- 2. res.len > 0 -> into_split_loop -> [e1, e2]
- res.len === 0, we did not get into split loop
- res.len > 0, we get into split loop
- why res = []?
- res = [] -> str is num -> [str_num]
- res.len > 0 -> into_split_loop -> [e1, e2]
- why we need to loop char by char?
- we need to get symbol +, -, *, why?
- so we can split and get the full cal form
- e.g. 2-1-1 (init dfs) -> (2-1)-1 sub dfs -> 2-(1-1) sub dfs
- so this dfs has 2 paths
- in the split loop, what is left_res and right_res
- left_res = [], [e1, e2]
- right_res = [], [e1, e2]
- why we need left_res and right_res?
- because left_res === cache or dfs
- because right_res === cache or dfs
- why we don't return directly if see cache?
- normally, if get cache, we should return, but here diff
- left_res is for later 2D loop
- right_res is for later 2D loop
- why cache / dfs -> then cal result?
- why not cal result -> cache / dfs?
- because dfs is bottom up
- we hold the result, hit the bottom, cal from bottom, then keep returning
- why left_res and right_res are array?
- because 2D loop, i stable, j loop
- in the 2D loop, why we put res.push within the 2D loop?
- why not after 1st inner loop, why not after outerloop?
- beause we need each of the result
- why the sum = e1 + e2, why we don't do sum = sum + (e1 + e2)?
- because we are not acc.
- if we don't ask why, then we blindly follow pattern
- simple:
- mp = new Map (l: 1. label -> area; 2. str -> val; 3. key -> val)
- x
- dfs
- res = [] (l: 1. g_track; 2. init_track; 3. level_track*)
- if str == '+' || str == '-' || .. (l: a + b + c + d -> a dfs + (b+c+d) dfs -> (a+b) dfs + (c+d) dfs ...
- left_res = []; right_res = [] (l: a+b+c+d -> a dfs + (b+c+d) dfs ....
- if mp.has(left_str), re 
- l: all dfs was returned, is outcome (cache)
- l: bottom up easy operation
- x
- if mp.has(right_str) .....
- l: all dfs was ...
- l: bottom up ...
- sum = 0 (l: 1. g_track; 2. init_track; 3. level_track*)
- after all prev dfs (l: bottom up easy operation)
- 2D left_res right_res loop (l: a+b+c+d -> a dfs + (b+c+d) dfs -> ...
- if res.len == 0 (l: a arr + (b+c+d) nothing arr -> [a]; all dfs was return, is outcome (cache))
- else (l: (a+b) arr + (c+d) arr -> arr; all dfs was return, is outcome (cache))
- start_func
- dfs has (1. start pt; 2. str; 3. arr, etc
- motion:
- original_string -> many_splits -> half_split -> original_string (repeated)
- o_s -> m_s -> h_s -> o_s (repeated)
- when return -> single_num -> [single_num] ->[single_num] * [single_num]
- loop === [res1, res2, res3]
- [res1, res2, res3] * another similar [r1, r2, r3]

- https://leetcode.com/problems/longest-increasing-path-in-a-matrix/ (\*)
- complex:
- why we need 2 max: outerloop max and dfs max?
- outerloop max: max after each full single dfs path
- dfs max: each sub dfs path (4 directions -> 4 decisions)
- outerloop max and dfs match both need
- why use index = i + '_' + j?
- because if we have the cell index, mp.get(ind) === min_dist_so_far
- on top of dfs
- 1. check boundary
- why return 0?
- we return -1, 2,3,4, '', [], because min_dist so return 0
- 2. hit block in middle
- for this leetcode, hit block in middle ~== water flow (pacific, atlantic flow)
- we flow backward, high to low
- 3. other condi?
- 4. seen?
- we put the seen in last place, why?
- because if we put seen before descending condition check, we ignore the descending condition
- must satisfy all necessary conditions before the seen.
- seen just blindly return, when saw it
- why use global_seen, not local_seen?
- because it is global path travel, we may hit the same cell again and again
- also we need to use global_seen as cache, global_seen.get(ind) === min_dist_so_far
- 5. block after all check?
- no need, as we don't modify the cell
- 6. operation?
- 7. 4 dir
- for the 4 dir, why we do r1, r2, r3, r4?
- because r1 = dfs(xxx), r2 = dfs(xxx), r3 = ..., r4 = ...
- max = 1 + max(r1, r2, r3, r4)
- each r1, r2, r3, r4 === sub dfs max
- why we need to have +1 here?
- because the base dfs return 0, if no +1 here, we are not able to acc
- simple:
- l: go down / go right
- map (l: no g_seen / local_seen, as revisit; l: after all dfs this level, is outcome)
- max = 0 (l: 1. g_track*; 2. init track; 3. level track)
- x
- dfs
- dfs(param) (l: asc/desc flow; l: info var along dfs)
- ind = c_i + c_j (l: use map, 2D -> 1D ind)
- l: interview (bound); l: 1. re nothing; 2. re overall (bit or every*) ...
- l: interview (asc/desc flow); l: 1. re nothing...
- map.has (l: after all dfs this level, is outcome)
- l: offer (l: re nothing; 2. re overall (bit / every / cache*)
- l: next candidate (4 dir)
- after all dfs
- curr_max = 1 + ma(dfs1, dfs2...) (l: after all dfs this level, is outcome; l: this level contribute 1)
- 2D loop
- l: 1. 2D loop -> dfs*; 2. 2D loop -> op
- max(max, dfs(curr_pt, inf) (l: asc/desc flow; l: info var along dfs)
- motion:
- case 1:
- [[9, 4], [6, 1]]
- 9 up (x)
- 9 down -> 6 -> 6 up (x, >= prevItem) -> 6 down (x, edge) -> 6 left (x, edge) -> 6 right (*) -> 1 -> 1 up (x, >= prevItem) -> 1 down (x) -> 1 left (x, >= prevItem), 1 right (x, edge) -> 1 (backtrack 1 len to 6), cache (? because 4_dir done) -> 6 (backtrack 2 len to 9), cache -> 9 -> 9 left (x) -> 9 right -> 4 -> 4 up (x) -> 4 down (get from cache 1) -> 4 left (x) -> 4 right -> 4 (backtrack 1 len to 9) -> 9 (4_dir finsih, cache, len === 3)
- in summary
- from 9, go 4_dir, down and right will go deeper dfs, will back track later


- https://leetcode.com/problems/accounts-merge/ (\*)
- https://leetcode.com/problems/accounts-merge/discuss/494151/JavaScript-Solution-DFS
- complex:
- for graph, why we use hash, rather than map?
- we can use use map, but hash is mush eaiser to assign vertex and assign arr/set to the end
- why we use global seen, in dfs travel; why not use a local seen?
- because when we travel, we want to hit the cycle; when it is cycle
- it means we stop and this dfs path is done, and return sub result to prev dfs
- why we have dfs in outerloop, then within dfs we have another dfs?
- because outerloop, we init the dfs
- within dfs, we need to dfs need to self travel
- within outerloop, return_email_arr = dfs(email), why return_email_arr can be []?
- because prev dfs travel may hit this email (vertex), so we hit again, we return []
- within outerloop, why we sort the email_arr?
- because looks nice and question asks
- within outerloop, why we unshift person_name to start?
- because question asks
- why we use first_email as vertex, then conenct rest of emails?
- why not do N^2, each node connect with each other once
- because we know that first_email is in the same boat as other email in arr
- It is representative, this also avoid N^2
- then why rest_email connects first_email only?
- this is the same idea that first_email as vertex, connect to rest_emails
- rest email only connects back to first_email
- why in same_arr, we form cycle; why in diff email_arr, same vertex can appear, hence edges inc?
- because some arr processes 1st, then other arr processes later
- why graph like this?
- [a]; a->x (no edge)
- [a, b]; a->b, b->a (cycle)
- [a, b, c]; a->(b and c); (same_arr, more set)
- [a, b], [a, c]; a->(b and c); (diff_arr, same vertex)
- why we need a name_hash?
- because name_hash[email] = person_name, so diff email as key entry, will have same person_name
- when build graph, why we check graph[curr_email] === undefined, then graph[curr_email] = new Set()?
- because later we do graph[curr_email].add(ele), without new Set() before, this is invalid add operation
- this allows natural operation
- when build graph, when forming a cycle, why we don't need j === 1?
- because j === 1, it is 1st email; it has vertex, but it has no edge
- why for edge we use set, not arr?
- because edge can be repeated, arr allows repeated, we don't want repeated.
- simple:
- l: graph node -> node or cycle
- l: single person has many emails (name_hash)
- l: 1. local_seen revisited; 2. g_seen !revisited*
- x
- in b(g)
- loop accs, loop acc (l:preprocess, simpler; b(g))
- name_hash[email] = name (l: single person has many emails)
- l: graph init, easy push later
- l: 1st ele -> rest, rest -> 1st ele*; 2. bi direction (cycle); 3. single direction; self connect (cycle)
- x
- dfs
- seen.has(email) (l: 1. local_seen revisited; 2. g_seen !revisited)
- return [] (l: 1. re nothing; re overall (bit* or every); re states)
- loop edges (l: 1. dir; 2. inc num; 3. edges*; 4 flip_game, etc)
- x
- process, actual
- res = [] (l: 1. g_track*; 2. init track; 3. level track)
- for(email of graph) (l: process === 1. travel graph*; 2. loop 0->n)
- email_arr = dfs(email) (l: dfs has start pt; 1. re nothing*; 2. re overall ...)
- email_arr.sort, email_arr.unshift(person) (l: better looking, name first, then emails)
- motion:
- case 1:
- 1. john, j_s@mail, j_n
- 1. john, j_s, j_00
- 2. mary, m
- 3. john, j_b
- 
- (1.0) build (arr form)
- j_s -> j_n, j_n (graph 1, branches)
- j_n -> j_s (g2, cycle)
- j_00 -> j_s (g3, cycle)
- m -> x
- j_b -> x
-
- (1.1) build (graph form)
- g1: j_s form cycle to j_n
- g1: j_s form cycle to j_00
- g2: j_n -> j_s
- g3: j_00 -> j_s
- m -> x
- j_b -> x
- 
- (1.2) build (code form)
- loop accounts (? name, e1, e2, e3)
- name_hash (? obvious)
- init graph {} (? can append)
- cycle path
-
- (1.0) data struct
- graph
- g_seen
- name_hash
- 
- (1.1) travel (graph form)
- j_s [j_s, push] -> j_n [j_s, j_n] -> x (cycle)
- j_s -> j_00 [j_s, j_n, j_00] -> x (cycle)
- m -> x
- j_b -> x
- 
- (1.1) travel (code form)
- loop graph (? g1, g2, g3..)
- return = dfs(email), -> see 1.2 <-
- arr.len > 0 (? email_arr.len > 0)
- append
- 
- (1.2)
- check g_seen
- set g_seen
- before_arr_op (name_hash)
- edges

- https://leetcode.com/problems/number-of-islands (\*)
- complex:
- why "1" and "0" in question?
- because question asking, we are not using 1 and 0
- on top of dfs
- 1. bounday check
- 2. hit block in middle
- 3. other condi?
- 4. seen?
- 5. block after all check
- 6. operations
- 7. 4 dir
- simple:
- l: go down / go right
- dfs
- l: interview (bound)
- l: interview (hit ocean)
- l: 1. re nothing*; 2. re overall ...
- l: offer (avoid ocean)
- l: next candiate (4 dir)
- res = 0 (l: 1. g_track*; 2. init track; 3. level track)
- if(g[r][c] === 1) -> dfs (l: start cell cascading)
- motion:
- case 1:
- st: grid (? obvious)
- tr: res (? # island)
- [[1, 1, 0, 0], [0, 0, 1, 1]]
- at (0, 0), cell == 1, set cell = 0; up, B; down, 0; left, B; right, 1_good;
- now go deep dfs at (0, 1), cell == 1, set cell = 0; up, B; down, 0; left, 0; right, 0;
- res = 1 (island done)
- see 0
- see 0
- see 0
- see 0
- see 1; set cell = 0; up, 0; down, B; left, 0; right, 1_good;
- now go deep dfs at (1, 3); up, 0; down, B; left, 0; right, B;
- res = 2 (island done)

- https://leetcode.com/problems/max-area-of-island (\*)
- complex:
- why standard 2D loop?
- because flood-fill
- 2D loop -> g[r][c] === 1 -> dfs -> max -> area = 0, why?
- 2D loop (flood-fill) -> g[r][c] === 1 (init cell) -> dfs (rest cells) -> max (after 1 dfs result) -> area = 0 (reset)
- on top of dfs
- 1. check boundary
- 2. block in middle
- 3. other condi?
- 4. seen?
- 5. operations
- 6. 4 dir
- simple:
- l: go down / go right
- dfs
- l: interview (bound)
- l: interview (avoid ocean)
- l: offer (assign ocean)
- l: offer (acc)
- l: next candidate (4 dir)
- max = 0 (l: g_track*; 2. init track; 3. level track)
- area = 0 (l: g_track; 2. init track*; 3. level track)
- l: 1. 2D -> dfs*; 2. 2D -> op
- if(g[r][c] === 1) (l: start cell cascading)
- within 2D loop, max, area = 0
- l: 1. g_track* ...
- l: 1. g_track; 2. init track* ..
- 
- motion:
- case 1:
- [[1, 1, 0], [0, 0, 1]]
- g[0][0] === 1, can get in, dfs
- inboundary, g[0][0] === 1 (can use)
- g[0][0] = 0 (? set, avoid loop)
- area === 1 (? because this dfs level)
- 4_dir; up, outbound; down, 0; left, outbound; right, 1, can go dfs
- 
- g[0][1], in bound and === 1
- g[0][1] = 1
- area === 2
- 4_dir; up, out; down, 0; left, 0; right, 0; backtrack
- 2D outloop, scan other cells like g[0][1], g[0][2], g[1][0], g[1][1], no use
- 
- until g[1][2] === 1
- inbound, can_use, 4_dir; area === 1

- https://leetcode.com/problems/making-a-large-island/ (\*)
- complex:
- why max = 0?
- it can be -1, -2, but 0 is enough, because we don't any max area
- later max = max(max, area)
- why set area = 0?
- for each area, we will label it and has area
- eventually, we connect 2 islands, to make largest
- why island label starts at 2?
- because 0 empty path, 1 is island, 2 is ready to use
- why we need a global_map?
- map.set(island_label, area_value), so each island has own label and own area
- why we don't put a global seen here?
- because it is a 2D loop when processing
- when travel, 2D loop -> new seen -> 4 dir loop
- we don't need a global_seen, but we need a local_seen before 4 dir loop
- 
- process: on top of dfs
- 1. check boundary
- 2. hit block in the middle
- why not use g[r][c] === 0?
- because g[r][c] === 0
- g[r][c] === 2,3,4,5,etc
- only when g[r][c] === 1, can connect other cells
- 3. other condi, no
- 4. other condi
- 5. operations
- ++area
- g[r][c] = label, why?
- because it indicates the cell belong to this label
- 6. 4 dir
- in outerloop of this dfs
- it is a 2D standard loop
- get in if g[r][c] === 1 -> dfs -> ++label (next island) -> area = 0 (reset)
- 
- travel: right inside the 2D loop
- why we use g[r][c] === 0, connect 4 directions?
- because g[r][c] === 0, turn g[r][c] === 1
- or g[r][c] === 2,3,4,5,etc (there is no g[r][c] === 1 any more)
- if g[r][c] === 0 -> new seen -> 4 dir loop (seen.add) -> reset seen, why new seen here?
- 1. connect 2 islands (2 directions)
- 2. connect 3 islands (3 directions)
- 3. connect 4 islands (4 directions)
- so we need a new seen here
- why area = 1?
- because we get in, g[r][c] === 0, turn g[r][c] === 1
- why 4 dir loop, we must have row_d and col_d?
- because we move future cell; row = curr_row + row_d; col = curr_col + col_d;
- 1. check boundary
- why no return here? because it is dir loop, not dfs
- 2. hit block in the middle
- mp.has(g[r][c]) === we have this island
- !mp.has(g[r][c]) === we don't have this island at all ~== g[r][c] === 0
- why?
- because there is no g[r][c] === 1 any more, only 0, 2, 3, 4, etc
- 3. other condi
- seen.has(g[r][c]) === we hit same island again
- we need to avoid, because later we have area = area + mp.get(g[r][c]);
- 4. block after all check
- seen.add(g[r][c]), seen this island
- 5. operations
- area = area + mp.get(g[r][c]), have 4 directions
- why max after 4 dir loop?
- because if put within 4 dir loop, we cannot
- 1 empty cell can connect to 4 directions, must after dir loop
- why at the end of entire fuc, return max ? max : m*n?
- because there is a chance that no 0 at all, so m*n
- how to diff same var name in same scope?
- e.g. using i, j, k in the same scope, very easy to overwrite each other
- so using curr_i, curr_j, curr_k
- simple:
- l: 1. up down left right*; 2. x_new = dx + x_old
- max = 0 (l: 1. g_track*; 2. init track; 3. level track)
- l: go down / go right
- area = 0 (l: 1. g_track; 2. init track* (acc); 3. level track)
- label = 2 (l: 1. g_track; 2. init track*; 3. level track)
- mp = new Map (l: 1. g_track;, 2. init track* (label -> area); 3. level track)
- paint_dfs_func
- l: preprocess, simpler
- l: interview (bound)
- l: interview (hit ocean / other label)
- ++area; g[r][c] = label (l: offer; 1. .. 2. init track* 3. ...)
- l: next candiate (4 dir)
- x
- preprocess, simpler; 2D loop -> if(g[r][c] === 1) paint_dfs; (l: cell = 0 and 1 and 2,3,4..)
- l: 1. 2D loop -> dfs*; 2. 2D loop -> op
- after paint_dfs -> area, mp, label (l: this level dfs complete, clean up)
- x
- process, actual; (1. 2D loop -> dfs; 2. 2D loop -> op*
- if g[r][c] == 0 -> connect (l: cell = 0, 4 dir label, etc)
- 4_dir_loop (l: 1. up down left right; 2. x_new = dx +x_old)
- l: interview (bound)
- l: interview (avoid same)
- l: interview (hit ocean)
- l: offer (avoid same)
- l: offer (cal area)
- max (l: 1. g_track*; 2. ....)
- end_func
- l: 1. many separated islands; 2. some separated islands; 3. no separated islands
- motion:
- case 1:
- [[1, 0], [0, 1]]
- paint (graph form)
- at i=0, j=0; see 1; label = 2, ++area; up, boundary; down, zero; left, B; right, 0;
- reset area = 0; reset label = 3
- see 0, cannot do
- see 0, cannot do
- at i=1, j=1; see 1; label = 3, ++area; up, 0; down, B; left, 0; right, B;
- reset area = 0; reset label = 4
- x
- travel (graph form)
- [[2, 0], [0, 3]]
- at i=0, j=0, skip
- see 0; up, B; right, B; down, see_label_3; left, see_label_2
- max = 3
- see 0; up, see_label_2; right, see_label_3; down, B; left, B
- max = 3
- at i=1, j=1, skip

- https://leetcode.com/problems/shortest-bridge/ (\*)
- complex:
- what is r1?
- r1 store all the 1st island i, j
- r2 store all the 2nd island i, j
- what is count = 0 vs count = 1?
- init cell -> rest cells
- 1st island, count = 0
- 2nd island, count = 1
- on top of dfs
- 1. check boundary
- 2. hit block in middle
- 3. other condi (no)
- 4. seen?
- 5. operation
- 6. block after all check
- 7. 4 dir
- why for graph: build graph -> process graph?
- paint island -> process island
- build graph -> process graph
- why min = Infinity?
- because anything assign, min is sure min
- why dist = abs(r2-r1) + abs(c2-c1) - 1?
- because c^2 = a^2 + b^2
- -1 because is like time - 1
- we have a bit more
- simple:
- st: 2 separate islands
- l: go down / go right
- count = 0; (l: start cell cascading to others until bound; count as whole)
- count = 0; (l: 2 separate islands)
- r1 = []; r2 = []; (l: 1. global track*; 2. init track; 3. level track)
- l: coordiate for lines
- x
- dfs
- l: interview (bound)
- l: dfs return (1. re nothing*; 2. re overall ...; 3. re states)
- l: interview (avoid invalid)
- l: offer (assign; avoid invalid)
- if(count === 0) r1.push (l: start cell cascading to other until bount..)
- l: next cadidate (4 dir)
- 2D loop (l: preprocess, simpler)
- another 2D loop (l: process, actual)
- let min = inf (l: 1. global track*; 2. init track; 3. level track*)
- in 2D loop cal dist (l: distance among 2 groups)
- l: 1. 2D distance cal; 2. 1D distance cal
- motion:
- case 1:
- st: grid (? obvious)
- st: r1 (? push pt)
- st: r2 (? push pt)
- min: (? min dist)
- 
- paint (graph)
- [[0, 1], [1, 0]]
- i=0, j=0, skip
- see 1; up, B; down, 0; left, 0; right B
- r1.push [0, 1]
- finish (++count)
- see 1; up, 0; down, B; left, B; right 0
- r2.push [1, 0]
- finish (++count)
- x
- cal (graph)
- r1: [0, 1]
- r2: [1, 0]
- 2D loop brute force; d_min = min VS |x2-x1| + |y2-y1| - 1
- 
- https://leetcode.com/problems/count-sub-islands/ (\*)
- complex:
- what is g1 and what is g2?
- g1 === g2 in same shape, g1 some areas include some areas in g2
- 1. cell_1 = 0, cell_2 = 0, common empty, but no island, IGNORE
- 2. cell_1 = 0, cell_2 = 1, cell_2 extra, 1st travel remove it, LEFT OUT IS COMMON (del init_cell, surrounding cell removed as well)
- 3. cell_1 = 1, cell_2 = 0, no use for cell_2, IGNORE
- 4. cell_1 = 1, cell_2 = 1, commmon island, dfs g2 will count
- why we need to have 2 dfs travel?
- graph: build graph (easier process) -> travel graph
- flood-fill: paint 1st time (easier process) -> paint 2nd time
- graph ~= flood-fill
- why in outerloop, check g1[r][c] = 0, g2[r][c] = 1?
- cell_2 got extra, if remove, left out is the island we need
- for this g1[r][c] = 0, g2[r][c] = 1 init cell, once start, all surrounding cells removed
- we don't even need to wait for the 2D loop to advance, it is clean up by surrounding
- on top of dfs,
- 1. check boundary
- 2. if block in the middle
- 3. other condi (no)
- 4. seen? (2D loop, stable)
- 5. operations (no)
- 6. block after all check
- 7. 4 dir
- simple:
- l: go down, go right
- dfs
- l: inteview (bound)
- l: inteview (g_seen; avoid_invalid; board_state_update)
- l: offer (update_board_state)
- l: board === big g_seen
- l: next candiate (4 dir)
- after_dfs
- l: b(g) === make task simpler
- g2[r][c] === 1 && g1[r][c] === 0, dfs g2 (g2 sub of g1; clean up g1)
- l: 2 ele: 1st ele to contain; 2. 1st ele extra; 3. 1st ele sub
- x
- res = 0 (l: 1. global track*; 2. init track; 3. level track)
- l: t(g) === b(g) make task simpler
- in t(g), g[r][c] === 1, dfs (l: from single cell cascading to other cells until bound; count as whole)
- motion:
- case 1:
- remove_cross (graph)
- st: g1 and g2
- tr: res (? for num of island, not cross)
- g1: [[1, 1, 0, 0], [0, 0, 0, 1]]
- g2: [[1, 1, 1, 0], [0, 0, 0, 1]]
- g1_pt and g2_pt move together
- until hit i=0, j=2; g1 has 0, g2 has 1; remove_cross
- set !can do, g2[0][2] = 0
- up, B; down, B; left, good (dfs) ---> i=0, j=1; up, down, left, good (dfs) ----> i=0, j=0; up, down, left, right (backtrack) ---> i=0, j=1, now go right (backtrack) ----> i=0, j=2 now go right
- rmove_cross
- now move to i=0, j=3
- i=1, j=0;
- move, move until hit i=1, j=3, cell === 1 (do nothing, as that is island we need)
- x
- paint (graph)
- 2D loop (?flood-fill)
- can_do
- dfs
- x
- dfs
- bound
- can_do
- set !can do
- op
- dfs_4_dir

- https://leetcode.com/problems/find-all-groups-of-farmland/ (\*)
- complex:
- why do I need to know maxRow, maxCol?
- this is for a single travel in outerloop
- because farmland is rectangular --> the up width === down width, left length === right length
- if we know the max i and max j in dfs travel, we know max width and max length
- when push result [start_i, start_j, max_row, max_col]
- the top of dfs check?
- 1. check boundary
- 2. block in middle check
- 3. other condi?
- 4. seen?
- 4. block it all check pass
- 5. do operations, set max (*) / push result / etc
- in outerloop, why we have to check if g[r][c] === 1 -> dfs?
- if without g[rc][c] === 1 -> dfs, then dfs just randomly travel
- why maxCol = 0 -> dfs -> res.push?
- because after dfs, all things got updated, and we get result
- simple:
- l: go down / go right
- maxRow, maxCol (l: 1. global track; 2. init track*; 3. each level track)
- dfs
- l: interview (bound)
- bound return (l: 1. re nothing*; 2. re overall (bit or every); 3. re states
- l: inteview (seen / board state updated)
- g[r][c] = 0 (l: offer / board state updated)
- maxRow = max(..) (l: 1. global track; 2. init track*; 3. each level track / rectangle)
- l: next candiates (4 dir)
- after_dfs
- res = [] (l: 1. global track*; 2. init track; 3. each level track / rectangle)
- in 2D loop, if g[r][c] === 1 (l: board state updated)
- maxRow = 0 ... (l: 1. global track; 2. init track*...)
- res.push (l: 1. global track .... / rectangle)
- 
- motion:
- case 1:
- st: grid (? obv)
- lo_tr: max_row, max_col (? for each 2D loop entry)
- g_tr: res_arr (? [x_min, y_min, x_max, y_max])
- 
- [[1, 0, 0], [0, 1, 1], [0, 1, 1]]
- at i=0, j=0; see 1; cell = 0 (set !can do); max_row = 0, max_col = 0;
- up, B; down, 0; left, B, right, 0; backtrack
- see 0
- see 0
- see 0
- reset max_row = 0, max_col = 0; now see 1; at i=1, j=1; cell = 0; max_row = 1, max_col = 1
- up, 0; down -> go to cell down, cell=0, mr=2, mc=1 -> go to cell right, cell = 0, mr=2, mc=2 -> go to cell top, cell=0, mr=2, mc=2 -> backtrack -> go back down (backtrack) -> go back left (backtrack) -> go back top (backtrack, stop) 
- within 2D loop
- res.push [x_min, y_min, x_max, y_max]

- https://leetcode.com/problems/web-crawler (\*)
- complex:
- why startUrl.split(/)[2]?
- http://abc.com -> (1) http: (2) '' empty str (3) abc.com
- why we need a domainName at the start of entire func?
- it is like leetcode paintColor, neighbour color (flood-fill) to be the same
- why we need res = []?
- res.push(url)
- why we need a global_seen?
- because it is a graph travel, may hit the same node again and again
- on top of dfs, check
- 1. has same domainName?
- 2. global_seen?
- 3. other condi?
- block it after check
- why we push result after all checks?
- res.push(url)
- because all condi pass, should push result
- what is htmlParser.getUrls(url)?
- it is like vertex -> edges
- startUrl === start vertex
- htmlParser.getUrls(startUrl) === edges
- simple:
- st: g_seen (l: info var along travel; avoid same)
- st: res = [] (l: info var along travel; store res)
- st: start_url (l: interview (1. contain*; 2. flow; 3. etc)
- l: https:// with double slash
- dfs
- l: interview; 1. contain*; 2. flow; 3. etc
- dfs return (l: re nothing*; re overall(bit or every); 3. re states)
- l: interview (g_seen)
- dfs return ....
- g_seen.add (l: offer; along; avoid same)
- res.push (l: offer; along; store res)
- edge_loop
- l: gen path: 1. dir; 2. inc num; 3. edges*; 4. flip games, etc
- start_func
- l: dfs has start point
- motion:
- case 1:
- a.com -> a.com/a (branch)
- a.com -> a.com/b (branch)
- a.com/a -> a.com (cycle)
- a.com/b -> a.com (cycle)
- 
- a.com === domain_name
- a.com same domain; a.com !seen; set a.com seen; res.push a.com;
- a.com has 2 edges -> a.com/a and a.com/b
- dfs a.com/a
- a.com/a same domain; a.com/a !seen; set a.com/a seen; res.push a.com/a
- a.com/a get edges; no edge; backtrack to edge loop
- 
- a.com/b same domain; a.com/b !seen; a.com/.b seen; res.push a.com/b
- a.com/b get deges; no edge; backtrack to edge loop


- https://leetcode.com/problems/number-of-distinct-islands/ (\*)
- complex:
- we have shape_seen, why we don't have a global_seen or local_seen?
- because global_seen or local_seen, we use i + '_' + j, to avoid hit the same cell again and again
- for this one, it is not path finding and we have a stable 2D loop
- also the entry: dir + up + down + left + right
- what are the condi check on top of dfs?
- 1. boundary check
- 2. other check: hit block in the middle
- 3. seen check (no global_seen or local_seen, ignore)
- 4. block it after all checks: g[r][c] = 0, to avoid loop
- for condi check, why we return 'o'?
- should we return '', zero, [], etc? we need to return something representation invalid
- so all condi return 'o'
- why I need to do dir + up + down + left + right for the island?
- island A === island B, when !rotate and !translate
- it is current_dfs_direction + 4_future_dfs_directions, why?
- 4 directions, the position is fixed, why we need a dir as well?
- because bottom of dfs return -> o + o + o + o (cannot diff) -> dir + o + o + o + o (can diff)
- it is like we are in a cell, curr dir + 4 directions
- why init cell -> rest of cells -> after done, this is result?
- because this is a standard flood fill
- why do we put an init direction in outerloop, for dfs?
- because at start, we cannot put up, down, left, right, so put x
- how many directions do we have?
- 1. x + o + o + o + o
- 2. x + up + down + o + o
- but this is just 1 dfs level
- multiple dfs levels -> xooooooordloo.... can be long
- why we cannot have let res = 0 -> ++res in 2D loop -> return res?
- because there are repeated islands, that is why we need dir + up + down + left + right, then put into set.add
- simple:
- st: 2D grid (l: 2D grid === big g_seen)
- l: go down / go right
- shape_seen (l: portion grid has area + dir; seen_this_shape)
- dfs
- l: interview (bound)
- l: 1. re nothing; 2. re overall (bit* or every); 3. re states
- l: base case, has own default dir
- x
- l: interview (avoid same; board updated)
- l: base case, has own default dir
- g[c_row][c_col] = 0 (l: offer, avoid same, board updated)
- l: next candiate (4 dir)
- l: each dfs level has own dir
- return dir + 4_dir (l: 1. re nothing; 2. re overall....; curr_dir + 4_dfs_dir)
- start_2D_loop
- l: 2D loop update board state
- if g[r][c] === 1 (l: 1. dfs; 2. !dfs)
- l: each dfs has own dir
- 
- motion:
- st: grid
- st: g_seen (? unique island)
- case 1:
- [[1, 0], [0, 1]]
- hit 1 -> x (init) -> up, xo -> down, xoo -> left, xooo -> right, xoooo
- g_seen: xooo
- hit 0
- hit 0
- hit 1
- hit 1 -> x (init) -> up, xo -> down, xoo -> left, xooo -> right, xooo
- g_seen (already)
- end of 2D loop, return g_seen.size

- https://leetcode.com/problems/swim-in-rising-water/ (\*)
- complex:
- why global_seen acting like a local_seen?
- when global_seen.clear() in each loop, it is like a new seen, so local_seen
- why convert 2D arr into 1D arr?
- e.g. last_cell = n*n-1
- e.g. curr_cell = row_num * i + j
- this is very easy to do set.add(curr_cell = row * i + j)
- on top of dfs, why we check conditions like this?
- 1. boundary check
- 3. other condi check e.g. empty_block, g[r][c] > time (time is not ready to flow)
- 2. seen check
- because we check easier condi, then more difficult condi
- why condi -> g[r][c] > time, then return?
- time (0, 0) -> g[r][c], it time (0, 0) flows to g[r][c], not g[r][c] -> time (0, 0)
- g[r][c] is the prev dfs level, become this future cell. g[r][c] > time, it means time is not ready yet
- why there a pattern: diff condi check on top of dfs -> then we block the condi?
- e.g. seen.has ... return -> seen.add(vertex)
- because pattern: check -> block
- in the outer loop, why we use while loop, instead of i j loop?
- because we need to reach last cell, we don't know when we can reach last cell
- so we need while loop
- in the outer loop, why global_seen.clear()?
- because global_seen act like a local_seen
- why dfs(0, 0) in outerloop?
- because each time we re-start
- why ++time in outerloop?
- time ~= height, height inc
- at last return, why time-1?
- not sure, because time = 0 at start, then it should start at 1?
- when do we use global_seen or local_seen?
- it is when we need to use entry: i + '_' + j, cell entry
- if it is like shape of island: dir + up + down + left + right, then we 
- don't use global_seen or local_seen, we use shape_seen
- why we have to use seen is that, we will hit the same cell again and again
- because it is path searching
- simple:
- l: go down, go right
- g_seen (l: info var along grid (set))
- l: 2D -> 1D -> ind: row*col
- var before dfs (l: tick for loop iteration; asc/desc flow (height))
- dir (l: 1. up down left right*; 2. x_new = dx + x_old)
- dfs
- curr_cell (l: 1. up down left right*; 2. x_new = dx + x_old)
- l: interview (bound)
- l: interview (avoid same)
- l: interview (asc/desc flow (height))
- l: offer (avoid same)
- l: next cadidates (4 dir)
- l: gen path: 1. dir; 2. inc num; 3. flip game, etc
- start_func
- l: 1. queen loop; 2. tar loop*
- l: g_seen.clear === local_seen
- ++time (l: tick for loop iteration; asc/desc flow (height)
- motion:
- case 1:
- st: grid
- st: lo_seen
- tr: time
- [[0, 2], [1, 3]]
- new lo_seen
- time = 0
- see 0; up, B; down, t_bad; left, B; right, t_bad; backtrack_stop
- 
- new lo_seen
- time = 1
- see 0; up, B; down, t_good; --> see 1; up, seen; down, B; left B; right, t_bad; backtrack --> back at 0; left B; right, t_bad; backtrack_stop
- 
- new lo_seen
- time = 2
- see 0; up B; down, t_good; --> see 1; up, seen; down B; left B; right, t_bad; backtrack --> back at 0; left B; right, t_good; --> see 2; up B; down t_bad; left seen; right B; backtrack_stop --> back at 0
- x
- new lo_seen
- time = 3
- see 0; up B; down, t_good --> see 1; up seen; down B; left B; right, t_good; --> see 3; up, t_good --> see 2; up B; down seen; left seen; right B; backtrack_stop --> back at 3; left seen; down B; right B; --> back at 2; backtrack_stop; --> back at 0; backtrack_stop
- return time - 1

- https://leetcode.com/problems/the-maze (\*)
- complex:
- why we don't have a global_seen / local_seen here?
- because robot will move forward / backward, so same cell may be visited again and again
- if we put global_seen, we may ignore many paths
- why we have a distance 2D arr?
- this uses the same method as maze 2
- each cell store the overall min distance, we reached so far
- why we store overall min distance?
- because when we reach the final destination, we have a final min distance
- we don't have any acc min distance (like campus bike), so we have to store
- final min distance
- why init each cell with infinity?
- when assign 1st value into dist array, we ca certainly assign value into it
- if we init 9999, that is not good
- if we assign -infinity, that means we store max distance
- why we assign start position in dist dp array, with 0?
- because start position has distance === 0
- if we don't assign 0, then dist[r][c] === infinity, then dist[r][c] + x, not possible
- on top of dfs, why there is no base check, condi check etc, why?
- later we have forward -> future_move_loop (boundary check in loop) -> backward
- because we check boundary + empty_block in future_move_loop
- in the 4 dir loop, why const row = start[0] + d_row
- because we steal a future move
- later forward -> future_move_loop -> backward
- why we cannot use const for row, const row = start[0] + d_row?
- why need to sue let row = start[0] + d_row?
- row = row + d_row, if row === const, how do we row cc
- why before the move_future_loop, we set let count = 0?
- count === count_step === each_block_move
- forward (steal future move, count +1) -> future_move_loop -> backward (count -1)
- forward / backward cancel each other, so count = 0
- why in future_move_loop, we have boundary check and empty_block check?
- because any thing block the movement, need to check
- 1. boundary will block movement
- 2. block in middle will block movement (g[r][c] === 1, block)
- g[r][c] === 1, block; g[r][c] === 0, empty_block
- why in future_move_loop, we have r = r + row_d?
- because we acc the move
- i.e. we lock 1 direction, then we keep moving that direction
- why ++count in future_move_loop?
- same reason, lock 1 direction, then we keep moveing that direction
- why we don't put dfs into future_move_loop?
- 4 dir loop -> future_move_loop, then dfs; why put dfs after future_move_loop?
- there are 2 ways to do direction dfs
- 1. each dir iteration -> dfs -> each dir iteration - dfs
- 2. or each dir itration -> future_move_loop -> dfs (*)
- why we need to backward after future_move_loop?
- because forward (count +1) -> xxx -> backward (count -1), cancel out
- why when count (acc) + dist[this_dfs_start_row][this_dfs_start_col] < dist[final_future_row][final_future_col], then we do assign full distance and dfs?
- count (acc) + dist[this_dfs_start_row][this_dfs_start_col] >= dist[final_future_row][final_future_col], >=, there is no value to assign and travel again
- as it is not min any more
- simple:
- see maze ii
- motion:
- st: grid
- st: dist_2D
- lo_tr: count
- case 1
- [[0, 1], [0, 0]]
- dp: [[0, if], [if, if]]
- at i=0, j=0; up, steal_bad, dist_same_bad; right, s_bad, d_same; down, s_good, d_good, count(1) + orig(0) < if(cell 1 0); dp: [[0, if], [1, if]]
- at i=1, j=0 (next dfs); up, s_good, dist_big; right, s_good, d_good; dp: [[0, if], [1, 2]];
- at i=1, j=1 (next dfs); up, s_bad, d_same; right, s_bad, d_same; down, s_bad, d_same; tracktrack;
- at i=1, j=0; down, s_bad, d_same; right, s_bad, d_same; BT
- at i=0, j=0; left, s_bad, d_same

- https://leetcode.com/problems/the-maze-ii (\*)
- complex:
- see the maze i
- if there is no init, dist[start[0]][start[1]] = 0,
- none of the calulation will work
- because dist[start[0]][start[1]] = infinity
- simple:
- st: grid (l: info var along grid; start -> dist 0; !reach -> dist inf)
- row/col (l: go down go right)
- l: start -> dist 0; !reach -> dist inf
- dir (l: 1. up down left right; 2. x_new = dx + x_old)
- dfs
- x
- l: dfs has start point
- dir loop (l: gen path: 1. dir; 2. num inc; 3. flip game; 4. etc)
- l: x_new = dx + x_old
- count = 0 (l: single dir keep moving)
- in_single dir loop
- l: future interview (bound)
- l: future interview (block)
- l: no seen, will revisit
- l: single dir keep moving
- l: steal move AND revert steal move
- l: 1. can dfs; 2. !can dfs
- l: eventually saturate
- end_dfs
- l: dfs has start pt
- l: shortcut
- motion:
- same as above

- https://leetcode.com/problems/flood-fill (\*)
- complex:
- why color click !== bucket fill, we take no action?
- because there is no dfs, then we don't want to go down
- color === bucket fill, we want to go down with dfs
- why we need to remember the color we click?
- the color we click is called neighbour color color
- which all same neighbour color should be painted with new color
- why there are 3 diff colors?
- g[r][c] === curr_color, it may diff from neighbour_color and paint_color
- neighbour_color === same color in the same area
- paint_color === we want new color for this area
- what is the color relationship?
- g[r][c] === neighbour_color, we are in the same area, can paint new color
- g[r][c] !== neighbour_color, not in same area, cannot paint new color
- g[r][c] === paint_color, local_seen, return, to avoid loop
- g[c][c] !== paint_color, so can paint
- why pass neighbour_color into dfs func?
- so we know the next dfs level, g[r][c] is the same neighbour
- simple:
- st: grid (l: update state)
- st: neighbour color (l: ele we want to change)
- st: paint color (l: ele we want to change to)
- row/col (l: go down and go right)
- dfs (l: paint colo
- l: interview (bound)
- l: interview (ele we want to change)
- l: interview (avoid see same candiate)
- l: offer (ele we want to change to)
- l: next candiate (4 dir)
- end_dfs
- start func
- l: shortcut
- l: dfs has start point
- motion:
- case 1:
- [[0, 0], [1, 2]]
- see 0; 0 -> 1; [[1, 0], [1, 2]]; up, B; down, prev_color_bad; left B; right, good;
- see 0 (new dfs level); 0 -> 1; [[1, 1], [1, 2]]; up, B; down, p_color_bad; left, p_color_bad; right B; backtrack
- backtrack at i=0, j=0; done

- https://leetcode.com/problems/pacific-atlantic-water-flow/ (\*)
- complex:
- what is pArr (pacific), aArr (atlantic)?
- pArr === local_seen
- why we don't modify the cell?
- there are 2 ways for local seen
- 1. modify cell
- 2. a copy
- here we make a copy, because we have pacific and atlantic, 2 diff
- on top of dfs, why we don't return anything
- return 0, '', [], none of them
- because if pArr[i][j] === aArr[i][j], that means common cell, common ground, return
- on top of dfs, why cannot flow, we need to return?
- because we need to flow high to low
- why flow high to low?
- 2 ways to paint: equal cell or descending / ascending
- here we using descending
- I don't think we can flow low to high
- on top of dfs, why we seen it, we return?
- to avoid loop, either modify cell or a copy; use a copy
- in the 4 direction pass to dfs, why pass arr into dfs?
- that is the local_seen, pArr / aArr.
- we are using same dfs func for pacific and atlantic, so use arr
- why we use current cell height as max, for current dfs? why not use same maxHeight for entire flow?
- because as we flow, we have 2 diff dfs level to flow; the height is diff in each dfs level; we cannot use same max height
- hence each dfs level is diff
- when paint grid, why we only go top and left?
- because that is for pacific
- when paint grid, why we only go right and bottom?
- because that is for atlantic
- why we don't do a 2D loop, then loop each cell?
- because base on the diagram, top and left === pacific, the init cell
- right and bottom === atlantic, the init cell
- for the init dfs, why we use -Infinity as maxHeight?
- because we want the first cell to flow and act like a maxHeight, no matter what
- why we use 2D loop for each cell, pArr[i][j] === aArr[i][j], to detect commont ground?
- because both seen it then it means both flow, hence common ground
- simple:
- st: g[i][j] (l: orig board)
- 
- st: st; 1. modify orig; 2. modify copy*
- st: init st; true === visit; false === !visit; 2 st -> true === true -> cross
- st: info var along the grid
- x
- st: st; 1. modify orig; 2. modify copy*
- st: init st; true === visit; false === !visit; 2 st -> true === true -> cross
- st: info var along the grid
- x
- dfs
- dfs(..., ..., arr) (l: info var along dfs travel)
- l: interview (bound)
- l: interview (g_seen)
- l: interview (able to asc/desc flow)
- l: offer (g_seen)
- l: next candiate (4 dir)
- x
- b(g)
- l: cascading from top
- l: cascading from top left
- l: cascading from top right
- x
- b(g)
- l: cascading from left
- l: cascading from left top
- l: cascading from left bottom
- x
- res = [] (l: 1. min/max; 2. acc*)
- t(g)
- in 2D loop
- l: 1. do dfs; 2. !do dfs
- l: true === visit; false === !visit; 2 st -> true === true -> cross
- in 2D loop; res.push (l: 1. min/max; 2. acc*)
- motion:
- case 1
- [[3, 5], [4, 4]]
- st: grid
- st: p_seen (pacific seen)
- [[f, f], [f, f]]
- st: a_seen (alantic seen)
- [[f, f], [f, f]]
- pacific -> left and top
- alantic -> right and bottom
- pacific_paint, top, 3
- see 3; [[t, f], [f, f]]; top, B; bottom, low_to_high_dist_good -> see 4; [[t, f], [t, f]]; top, seen; bottom B; left B; right, good -> see last 4; [[t, f], [t, t]]; top, good -> see 5; top, B; bottom, seen; left, seen; right B; backtrack; -> BT at last 4; bottom B; left seen; right B; -> BT at first 4; -> BT at 3; left, B; right seen; done
- pacific_paint, top, 5; cannot move; loop stop
- pacific_paint, left -> 3 and 4 seen
- 
- alantic_paint, right and bottom
- [[f, f], [f, f]]
- 5 paint stop; 4 and 4 paint, stop; so 3 never paint
- end: [[f, t], [t, t]]
- x
- do_common
- 2D loop p_arr and a_arr

- https://leetcode.com/problems/battleships-in-a-board/ (\*)
- complex:
- why for flood-fill, we need to use standard 2D loop?
- because init cell -> all connected cells paint
- will not touch other areas
- why in the 2D loop, we need to check empty cell?
- because init cell -> all connected cells paint
- will not touch other areas
- why in the 2D loop, we ++res?
- because init cell -> all connected cells paint
- so that is the whole area === result
- why we check boundary on top of dfs?
- because future cell can travel or not
- why we check empty cell on top of dfs?
- because future cell can travel or not
- in the boundary check / empty_cell check, why return nothing?
- because we paint cell === result count
- what u want me return, 0, '', [], none
- why we modify the cell?
- paint the cell, we don't want to hit again global_seen
- why 4 directions?
- future cell can travel or not
- simple:
- st: the board (l: state; g_seen)
- row (l: go down)
- col (l: go right)
- dfs
- l: interview (bound)
- l: interview (g_seen)
- dfs (l: 1. re nothing*; 2. re overall (bit or every); 3. re states)
- g[i][j] = '.' (l: offer (g_seen); 1. modify the board*; 2. modify copy)
- l: next candiates (4 dir)
- before 2D loop; res = 0 (l: 1. min/max*; 2. acc*)
- in 2D loop; (l: 2D arr -> 2D state)
- g[i][j] = 'X' (l: 1. do dfs; 2. !do dfs)
- in 2D loop, ++res; (l: 1. max/min; 2. acc*)
- motion:
- simple flood-fill with ++res

- https://leetcode.com/problems/course-schedule/ (\*)
- complex:
- why we detect the cycle in outerloop?
- because if 1 iteration is cycle, then return false
- if the outerloop does not return, we have a final return after outerloop
- this is typical pattern
- why we init local_seen at each iteration, in outerloop?
- because we have an outerloop here; it manages its own dfs path
- why I don't detect global_seen.has, local_seen.has in outerloop?
- because we have it detect within dfs.
- again, 1 iteration fail, return within outerloop;
- finisih all iterations, return success at the end
- when build graph, why we can have 2D arr or hash?
- because there are 2 ways to build graph; 2D arr === hash
- why the graph is 1 direction?
- because [0, 1], if do 0 then 1 must do first, 0 -> 1
- we cannot go 1 -> 0 in graph, that is not the question asking
- why local_seen === cycle, global_seen === avoid_loop?
- local_seen === cycle, because it is in own dfs path, we hit again
- global_seen === avoid_loop, because it is in entire dfs path
- why we do: local_seen.add -> dfs -> local_seen.del?
- because node in local_seen, in this dfs path need to be in sync
- each dfs is like each sub path
- why we do: dfs -> global_seen.add?
- because after dfs all done, global_seen can say we done visit for this node
- why only this question require local_seen.delete after edge loop?
- because denote_max_bomb, max_time_to_inform_employee, critical_connection_in_network; either is using global_seen or local_seen, but none of them do local_seen.del after edge loop
- if we are using global_seen, it does not make sense global_seen.del, why?
- because global_seen.del is global, it needs to persist
- local_seen can be deleted in each dfs path
- simple:
- see course schedule i
- motion:
- case 1:
- [[1, 0]]
- st: graph (ob)
- st: local_seen
- st: g_seen
- build (graph)
- 1 -> 0 (use preqs arr to build)
- travel (graph)
- loop 0:
- 1 -> 0 (pt at 0)
- local_seen (*); g_seen (*); set local_seen, {0}; edges (x); unset local_seen, {}; set g_seen {0}
- loop 1:
- 1 -> 0 (pt at 1)
- lo (*); g(*); s lo (*), {1}; edges -> dfs; 
- now at 0; lo(*); g_seen (x, aleady has 0); return !cycle -> backtrack
- now back at 1; unset local_seen, {}; set g_seen {0, 1}; return !cycle -> backtrack
- x
- case 2:
- [[0, 1], [1, 0]]
- st: graph
- st: local_seen
- st: g_seen
- build (graph)
- 0 -> 1 and 1 -> 0 (cycle)
- travel (graph)
- loop 0:
- pt at 0; lo (*); g (*); s lo, {0}; edges -> dfs
- now at 1; lo(*); g(*); s lo, {0, 1}; edges -> dfs
- now back at 0; lo(x) -> return cycle -> backtrack
- now back at 1; return cycle -> backtrack
- loop 1:
- 0 -> 1 and 1 -> 0 (cycle)
- pt at 1; no chance to run

- https://leetcode.com/problems/course-schedule-ii/ (\*)
- complex:
- why glocal_seen's entry === course dep order?
- e.g.
- [0, 1] === to do 0, must do 1 first
- graph 0 -> 1
- dfs bottom up, 1 -> 0
- so result === do 1 first, then do 0, which question asking
- e.g.
- [1, 0] === to do 1, must do 0 first
- graph 1 -> 0
- dfs bottom up, 0 -> 1
- so result === do 0 first, then do 1
- summary: course dep order === dfs travel order
- why within dfs, why put local_seen before global_seen?
- because local_seen === cycle; global_seen === avoid_loop
- why return true (local_seen)?
- return === we seen this in own dfs path
- true === cycle, why?
- because seen this in own dfs path, if keep going, cycle
- why return false (global_seen)?
- return === we seen this in global dfs paths
- false === not a cycle, why?
- cycle is detected by local_seen, not our task; not a cycle, because we just seen this
- why put local_seen.del, global_seen.add after dfs?
- because after dfs finish
- why only course_schedule require local_seen.del after edge loop?
- because max_num_denote_bomb, max_time_inform_employee, crital_connection_in_network; either using local_seen or global_seen, but none of them need local_seen.del after edge loop
- it does not make sense, that global_seen.del, why?
- because it is global_seen.del === global, it needs to persistent
- local_seen.del can be done
- simple:
- st: graph (l: node -> node or cycle)
- st: g_seen (l: 1. see node in order, after dfs loop; 2. everything good, then commit)
- st: local_see (l: commit then revert)
- b(g)
- l: init graph, easy push later
- dfs
- l: interviews
- l: offer; 
- local_seen.add (l: commit then revert)
- in_edge_loop (l: 1. re nothing; 2. re overall* (bit or every); 3. re states)
- after_edge_loop (l: 1. see node in order after dfs loop; 2. everything good then commit)
- after_edge_loop (l: try every, no cycle, re good)
- start_func (l: no start pt, loop -> dfs)
- start_func (l: 1. re nothing; 2. re overall....)
- end_func (l: try every, no issue, re good)
- motion:
- please have a look at course schedule i
- case 1:
- [0, 1]; take course 1 then take couse 0
- [0, 1] (preq)
- 0 -> 1 (graph)
- travel:
- at 0; local_seen; g_seen; set ... edges -> dfs
- now at 1; ..., ..., .. edges -> dfs (backtrack return); unset local_seen; set g_seen {1} (the trick is backward add)
- now at 0; unset local_seen; set g_seen {1, 0} (the track is backward add)


- https://leetcode.com/problems/critical-connections-in-a-network/ (\*)
- complex:
- why we put seen.has in outer loop?
- because seen.has in outer loop make it faster.
- seen.has can sit in outer loop and seen.has can sit in dfs, at the same time
- why dfs(child_ind, parent_ind), has child_ind, parent ind?
- because 3 ways: parent -> child -> edge
- why 3 ways?
- because dfs(child_id, parent_ind), then pass dfs(edge_ind, child_ind)
- why we need to label each node with rank?
- otherwise, how do I know which one is more important, which one is on top
- parent -> child -> edge
- why rankAtNode = array(n).fill(-1), why use -1 or 0?
- because the rank starts at 1
- why we have 2 graph assignments?
- beacuse graph[vertex] = edge and graph[edge] = vertex
- why rank starts at 0, not 1?
- because in dfs, we have ++rank, which === 1
- why on top of dfs, ++rank?
- beacuse that is the real dfs rank
- why on top of dfs, we do not check child === parent?
- because we are not checking child === parent, parent (*) -> child -> edge (*)
- we are checking parent === edge, need to skip
- why use Array.from(set) to loop set?
- because set is set, not arr; Array.from can help
- why compare child rank with edge rank, after dfs?
- because child rank and edge rank should have the latest rank
- why assign smaller edge rank to child rank?
- because child rank will be on top once again; parent (top) -> child (bottom 0) -> edge (bottom 1)
- why compare curr_rank with edge rank, after dfs?
- because edge rank should have latest rank;
- curr_rank < edge_rank, that means edge_rank (top) -> curr_rank (bottom), so edge is imporant now -> [edge_ind, child_ind]
- why not curr_rank > edge_rank, then push result? curr_rank (parent) -> edge_rank (child)
- because the prev rankAtNode[child_ind] = min(edge_ind), we update with smaller, so it is similar
- also because we re-arrange parent child order
- why we don't use child_rank VS edge_rank?
- because child_rank keeps updating, it is not stable
- why I use local_seen (path.add -> dfs -> path.del) and global_seen here?
- why we don't use local_seen in critical_net_work_node (leetcode) and denote_max_bomb (leet_code)?
- because this quesion is to detect cycle; then local_seen is a good way to detect cycle
- simple:
- st: graph (l: node -> node or cycle)
- st: g_seen_arr (l: info var along each node; init condi)
- st: g_rank_arr (l: info var along each node, init num)
- st: res (l: [{curr_node, parent_node}]
- b(g)
- l: bi-direction
- l: graph init, later easy push
- before_dfs, rank = 0 (l: rank = 0 among start of network)
- l: interview -> local_seen
- l: interview -> g_seen
- l: offer -> ++rank
- ++rank (l: a global var, dfs will update it, so save it for this dfs level)
- l: avoid see same candidate (local)
- l: avoid see same candidate (global)
- in edge loop,
- l: 1. curr interivews; 2. future interviews; 3. curr + future interviews
- l: seen + 3 ways connect: parent_node* -> curr_node* -> future_node*; parent_node === future_node -> dup
- l: use best future node, to update curr node
- l: curr node rank < future node rank -> curr node on top -> critical
- end_edge_loop
- fresh -> local_seen.add -> dfs_loop -> local_seen.rm (l: just commit later revert)
- dfs_loop -> g_seen.add (l: wait for ready to commit)
- start_func
- loop -> dfs (l: each node as start, update entire network, eventually no more update)
- motion:
- case 1:
- [0, 1], [0, 2]
- st: preq, [0, 1], [0, 2]
- st: g_seen (arr), [f, f, f]
- st: rank (arr), [-1, -1, -1]
- st: graph, 0 -> 1, 2; 1 -> 0; 2 -> 0
- build (graph)
- 0 -> 1, 2
- 1 -> 0
- 2 -> 0
- travel (graph)
- 
- dfs(ci_0, pi_-1)
- graph: 
- 0 (child_ind) -> 1 (ei) and 0 (ci) -> 2 (ei)
- code: 
- g_seen (*); set g_seen (*), [t, f, f]; curr_rank = 1, child_rank = 1, [1, -1, -1]; 
- edges (1, 2); edge_ind !== parent_ind (*); dfs(ci_1, pi_0)
- x
- dfs(ci_1, pi_0); g (*); s g (*), [t, t, f]; cr = 2, ci_r = 2, [1, 2, -1]; edges (0); ei !== pi (x), next_loop, end_func, BT
- now back to 0; 
- ei_rs vs ci_r -> 1(2) vs 0(1) -> 0(1);
- ei_r vs ci_r -> 1(2) vs 0(1) -> 0(1); -> push [ei_1, ci_0];
- x
- now we done 1, up to 2 now
- ei !== pi (x); dfs(ci_2, pi_0);
- x
- g (*), set g (*), [t, t, t]; cr = 3, ci_r = 3, [1, 2, 3]; edges(0); ei !== pi (x), next_loop, end_func, BT
- now back at 0;
- ei_rs vs ci_r -> 2(2) vs 0(1) -> 0(1)
- ei_r vs ci_r -> 2(2) vs 0(1) -> 0(1); -> push [ei_2, ci_0]

- https://leetcode.com/problems/detonate-the-maximum-bombs/
- complex:
- why there are 2 ways to init dfs?
- 1. direct dif; e.g. have an init index, then dfs all the way
- 2. loop -> then dfs
- which way to choose?
- for this question, we don't have a single index, so it is likely loop -> then dfs
- when do we use global seen? when do we use local seen?
- if we have loop -> then dfs, then we need to use local seen.
- (because we have multiple init dfs ways, so local seen)
- if we have direct dfs, then we use global seen.
- (because there is 1 dfs way, so use global seen, seen or not seen)
- why we need to have max in outerloop?
- because there is no submax within dfs, there is only acc.
- there is no outerloop max and dfs submax, 
- because each iteration in outerloop, max is enough
- we compare each diff dfs path, and find out the max, among diff dfs paths
- why we use 2D loop to build graph?
- for max time to inform employee question, we use 1D array to build graph
- because we have manager_id = manager_arr[employee_ind]
- for this one, i=0, denote self + rest
- i=1, denote self + rest
- i=2
- so use 2D array to build graph
- for bomb array, why each element === [x, y, radius]?
- because x, y we know the position
- having radius, we can use c^2 = a^2 + b^2, to compare the radius
- if raidus >= the c distance, we can denote; otherwise, we cannot
- why we need to have i_raidus (we use to compare c distance) and j_radius (we don't use)?
- why we need to have x_i, y_i, then x_j, y_j?
- because i stable, then j loop;
- use this way we can exhaust all 1 vs 1 combo
- why we need to use this formula, c^2 = a^2 + b^2?
- because radius_i compare with c distance
- if radius_i >= c, we can denote, then we need to push to edges arr
- this comes up a question, for graph, do I use new Set() or just use arr?
- 1. use arr, we can just push element, we can loop edge loop very easy (many people use this, this question uses)
- 2. use set, set.add(); when loop Array.from(edge_set)
- when we build graph, why we care graph[vertex] init or not?
- not init, graph[vertex] = [], then graph[vertex].push
- already init, graph[vertex].push, directly
- why on top of dfs, why we have acc here, why not submax here?
- becuase we have max in outerloop, to compare.
- here we acc each dfs path, to form acc
- why I cannot use i in edge loop directly, why use e_ind = edges[i]?
- i is not the real thing, it is the index; e_ind = edges[i], is what we push, when build graph
- why we use seen.has within edge loop, not on top of dfs?
- 2 ways to put seen.has
- 1. on top of dfs (for curr)
- 2. within dfs loop (for future)
- why in edge loop, we have ++acc?
- beause it is for this edge iteration, so ++acc; we have other edge iteration
- so at least we finish this edge loop iterations
- then we have ++acc; acc = acc + dfs(edge_index), this level + its sub_level
- simple:
- st: local_seen (l: dfs -> loop; each ele has a chance to dfs)
- st: graph (l: cycle or node -> node)
- b(g)
- l: 1. avoid cycle in b(g); 2. do useful in b(g); 3. avoid cycle in t(g)
- init graph, easier later push
- dfs
- x
- local_seen? return 0 (l: interview; cannot denote anything)
- l: offer
- before_edge_loop (l: 1. max/min; 2. acc*)
- in_edge_loop (l: 1.max/min; 2. acc*)
- end_edge_loop (l: can denote self)
- start_func
- new Set() (l: each ele has a chance to dfs)
- max = max(max, dfs) (l: each ele .....)
- l: 1. re nothing; 2. re overall (re bit* or re everything); 3. re states
- motion:
- case 1:
- [[1, 1, 1], [3, 3, 5]] (2 bomobs)
- st: bomb_arr
- st: graph
- st: lo_seen (set)
- tr: max
- tr: acc (? local acc = dfs())
- build (g)
- [1, 1, 1] === 0 ind
- [3, 3, 5] === 1 ind
- graph: 0 -> 0; 1 -> 1; 1 -> 0
- travel (g)
- loop -> dfs
- i=0; new lo_seen
- lo(*); s lo(*), lo_seen: {0}; acc = 0 (? edges); edges(0) -> dfs(0)
- x
- dfs
- lo(x), re 0, BT
- now come back at edges(0); ++acc(1); re acc(1); max = 1
- x
- i=1; new lo_seen
- lo(*); s lo(*), lo: {1}; acc = 0; edges(0, 1) -> dfs(0)
- x
- dfs
- lo(*), s lo(*), lo: {1, 0}; acc - 0; edges(0) -> dfs(0)
- x
- dfs
- lo(x), re 0, BT
- now come back at edges(0) -> dfs(0) BT; ++acc(1), re acc(1)
- now back at edges(0, 1) -> dfs(1)
- x
- dfs
- lo (x), re 0, BT
- now back at edges(0, 1) -> dfs(1); end edge loop ++acc(1+1=2), re acc(2)

- https://leetcode.com/problems/time-needed-to-inform-all-employees/
- complex:
- why there is no loop then dfs?
- becaus we have a single headID
- why we don't need a 2D loop here?
- i loop all employee index
- j loop loop sub employee index
- because manager_arr already have index === employee, val === manager
- then manager_arr[employee_can_also_be_manager] = manager_id
- then graph[manager_id] = employee_id
- when build graph, when loop employee, why i === headID, we skip
- because manager_arr = [-1, 2, 2, 2]
- when i = 0, then val = -1; manager_arr[-1] === undefined, so need to skip
- why only have 1 skip, i === headID; why not more
- we only have 1D employee loop;
- also we only have 1 headId
- why we need submax = Max(submax, dfs(new_head_id)) in edge loop?
- because we have diff dfs paths, we need to get the max
- why timeInform[curr_head_id] + submax?
- timeInform[curr_head_id] === this level
- submax === another dfs level
- why we don't have local_seen here, only global_seen?
- because only course_scheduler (leetcode), ask to detect cycle; this does not ask to detect cycle
- simple:
- l: graph === 2D arr, when vertex === arr_ind, push ele === push edges
- b(g)
- l: 1. avoid cycle in b(g); 2. avoid cycle in t(g)
- t(g)
- l: dfs has start point
- track_var in edge loop (l: 1. max/min*; 2. acc)
- l: prev_state + curr_state + future_dfs_state
- start_func (l: dfs has start point)
- x
- motion:
- case 1:
- st: manager <-> employee, [2, 2, -1, 2, 2, 2]
- employee === arr ind (? order cannot change)
- manager === val (2) (? can change)
- st: graph
- st: g_seen (2D arr)
- st: time, [0, 0, 1, 0, 0, 0]
- tr: submax = 0 (? for edges)
- x
- build (g)
- 0 -> x
- 1 -> x
- 2 -> 0, 1, 3, 4, 5
- 3 -> x
- 4 -> x
- 5 -> x
- x
- travel (g)
- dfs(2); g(*); s g(*), {2}; submax = 0; edges(0, 1, 3, 4, 5) -> each_dfs;
- dfs(0); g(*); s g(*), {2, 0}; submax = 0; edges(x); re time(0)=0 + submax=0, BT
- dfs(1); g(*); s g(*), {2, 0, 1}; submax = 0; es(x); re time(0) + submax, BT
- dfs(3)...
- dfs(4)...
- dfs(5)...
- now back at edges(0, 1, 3, 4, 5); time(2)=1 + submax=0, BT

- https://leetcode.com/problems/minesweeper/submissions/
- complex:
- why do we need 8 cell grid directions?
- because 1 click in the middle, all 8 cell grid directions get exploded
- it is like a sun shine.
- why init click has start_row and start_col?
- because that is where we start and we land on the grid.
- why there is no loop then dfs?
- because we have click (start_row, start_col), then we init dfs, then go down
- in the init dfs, why we need to handle mine (M) or init dfs?
- because if we don't handle mine now, it will go down to dfs, dfs will look for all future 8 directions. There is no way to handle current mine
- why we pass 8 directions to dfs?
- because later we have row = curr_row + row_d AND col = curr_col + col_d, for future move
- why the board has the actual value?
- because when we start to to click and dfs each cell, we need to know mine (M, acc num), empty (E, put into dfs queue), blank (B, reveal cell), digit (D, surround mine num), reveal mine (X, explode)
- because we can acc mine num and dfs queue
- why in the top of dfs, we have an empty dfs queue array; why not use a global array?
- because each dfs will have its own click (or starting point); it will hit 8 grid directions and form new dfs queue, in this dfs level.
- next dfs level will have own starting point
- within dfs, why we loop the 8 dir array directly? Why we don't have other loop operation?
- because there is no other operation; we don't need seen.has as there is no cycle hit
- why if we click a cell, it is like a sunshine; shine 8 directions
- because the middle is the central cell, then 8 directions are the shines
- why we loop the 8 directions?
- it can be 4 directions (e.g. flood fill) or 8 directions (mine sweep)
- because it clicks in middle, then it explodes in all 8 directions.
- it form row = curr_row + row_d; col = curr_col + col_d
- why we need row = curr_row + row_d; col = curr_col + col_d?
- because after each direction, we will form a new future move, hence we can check boundary, for future move
- why we only check boundary, we don't have other stuff to check?
- because the next cell will be
- mine (M, looks like a mine)
- empty (E, more dfs path)
- blank (B, reveal blank cell)
- digit (D, surround mine num)
- explode (X, explode mine)
- why there is no seen.has on top of dfs?
- because there is no cycle we will hit, not graph
-
- in dir loop, why we need to care mine (M)?
- because there we acc the mine num, and assign to the click point
- it also helps to stop dfs; because hit the stop point
- why we need to care empty square (E)?
- because if it is empty, we can push to queue arr, then loop -> dfs
- this allows new starting point
- why we don't care blank (B)?
- because aleady known AND there is no contrib to mine acc and dfs queue
- why we don't care digit (D)?
- because known AND there is no contribute to mine acc and dfs queue
- why we don't care explode (X)?
- Because it exploded, it is game over.
- Further to M, E, B, D, X, if other dfs path done it before, current dfs path should ignore it (to avoid repeated action)
- why we acc mine num?
- because need to assign mine num to this starting point.
- why we assign starting point mine num, there is no further dfs?
- because we hit the mine (stop point), we need to stop now, no dfs
- why we assign acc mine num to the starting point's cell?
- because to warn user that there are mines around; it is for the UI of the game
- so why do we assign blank to the starting point?
- because in this dfs level, if click is used, to reveal it, to let UI know.
- the dfs queue is below, is acting like further click (further reveal)
- why we assign blank before next dfs?
- because it is this dfs level, we need to finish the task here
- why the element in queue order is the direction order?
- because we loop in the 8 grid directions, so that is the loop order
- queue order === direction order
- why dfs return, it returns from the bottom?
- because dfs travel from top to bottom, when it reaches a stop condition, it travels from bottom to top, as a whole abstract.
- there is no way for it to travel drectly from starting point
- 
- why we need to use global, local, curr, etc to diff local var and global bar?
- if nested func, it is very easy to confused. must use
- why only empty path (E), we push to the dfs queue?
- because we do not want to dfs easier, must be careful dfs
- why we use board[r][c] = string(mineNum)?
- because all cells are string; why we need to use number
- why above the loop dfs queue, we need to board[r][c] = 'B'?
- because need to clean this cell, then move to next dfs;
- if no clear, we cannot move to next cell
- simple:
- row (l: cell position)
- col (l: cell position)
- l: sun light direction (4 dir or 8 dir)
- l: dfs has a start point
- dfs
- x
- dfs
- l: interviews (curr interview or future interview*)
- l: go through loop, track var updated (mine #)
- l: diff ways to gen dfs path: dir gen (straight dfs or acc dfs*)
- 8 dir loop (l: diff way gen dfs path: dir gen)
- check bound (l: interview: curr or future*)
- l: go through loop, track var updated (mine #)
- l: diff ways to gen dfs path: dir gen (straight dfs or acc dfs*)
- end_dir_loop (l: update curr state, next can work; l: diff ways to gen dfs path: dir gen (arr to store))
- end_dfs_func (l: cell (unopen/open/unexplode/explode/digit))
- start_func (l: shortcut early return)
- motion:
- case 1:
- [[E, E], [E, E]], all empty
- st: grid (Q)
- st: lo_path
- st: mine_num
- tr: 8_dir
- click at [1, 0]
- at [1, 0]; 8_dir_loop; check bound, Mine, Empty_push_queue; up, good, lo_path: [[0, 0]]; NE, good, [[0, 0], [0, 1]]; right, good, [[0, 0], [0, 1], [1, 1]]; all_other dir B;
- end_loop; M# > 0, cell = M or M# <= 0, cell = Blank, loop -> dfs;
- [[E, B], [E, E]];
- x
- [[0, 0], [0, 1], [1, 1]] -> [0, 0], dfs -> 8_dir_loop; lo_path: [[0, 1], [1, 1]]; rest dir B or BL; end_loop, M# <= 0, cell = BL
- x
- [[0, 1], [1, 1]] -> [0, 1], dfs -> 8_dir_loop; lo_path: [[1, 1]]; rest B or BL; end_loop, M# <= 0, cell = BL; [[B, B], [B, E]];
- [[1, 1]] -> [1, 1], dfs -> 8_dir_loop; lo_path: []; rest B or BL; end_loop, cell = BL; [[B, B], [B, B]], BT
- [[0, 1]_BT, [1, 1]] -> [1, 1]_to_finish, BT (most of time hit B or BL)
- [[0, 0]_BT, [0, 1], [1, 1]] -> [0, 1], [1, 1]_to_finish, BT (most of time hit B or BL)

- https://leetcode.com/problems/where-will-the-ball-fall (\*)
- complex:
- simple:
- st: arr_track (l: care only where balls end, 1D arr enough)
- dfs
- l: interview
- left === -1; right === +1
- |*/
- \*|
- \  */
- \*  /
- 
- l: offer
- \
-   *
- OR
-   /
- *
- x
- l: next candidates
- \
-   *
- OR
-   /
- *
- x
- start_func
- each cell has a chance to dfs
- motion:
- st: grid: [[1, 1], [-1, -1]] => [[\, \], [/, /]]
- st: res: [i] (? each col)
- dfs
- r=0, c=0
- hit left wall (x)
- h_r_w (x)
- hit v (\_1 + /_2, x)
- hit v (\_2 + /_1, x)
- hit bottom (x)
- / go left (x, no /)
- \ go right (*) -> dfs (BT)
- x
- dfs
- r=1, c=1
- h_l_w (x)
- h_r_w (x)
- hit_v (x)
- hit_v (x)
- hit bottom (*) -> re c-1; BT
- x
- r=0, c=1
- h_l_w(x)
- h_r_w(*) -> BT

- https://leetcode.com/problems/concatenated-words/
- complex:
- simple:
- const set = new Set (l: condi dfs)
- x
- dfs
- base_case (l: interview (valid?))
- l: next candidate
- l: gen paths: 1. dir; 2. edges; 3. arr; 4. horizontal ele merge -> vertical next ele*
- if set.has(tmp_w) -> dfs (l: 1. dfs; 2. condi dfs*; 3. no dfs)
- dfs(new_word, num+1) (l: info var along: 1. compass; 2. energy level*)
- condi = true -> re true (l: re nothing*; 2. re overall bit/every; 3. states)
- end_char_loop -> re false (l: try every, fail)
- start_func
- loop word arr (l: form: 1. bottm up form; 2. top bottom form (easy)*)
- motion:
- case 1: 
- [a, b, ab]
- st: arr: [a, b, ab]
- st: set: {} (? unique for a, b, ab)
- st: res: [] (? push)
- (1) a
- un-concat a -> dfs
- dfs
- a (end_str_x; concat_x) -> a (in_set_*; un-concat_*) -> '' (end_str_*; concat_x; re false; BT)
- (2) b
- un-concat b -> dfs
- dfs
- b (end_str_x; concat_x) -> a (in_set_*; un-concat_*) -> '' (end_str_*; concat_x; re false; BT)
- (3) ab
- un-concat ab -> dfs
- dfs
- ab (end_str_x; concat_x) -> a (in_set_*; un-concat_*) -> b (end_str_x; concat_x) -> b (in_set_*; un-concat_*) -> '' (end_str_*; concat_*; re true; BT)

- https://leetcode.com/problems/find-if-path-exists-in-graph
- complex:
- simple:
- st: graph (l: node -> node or cycle)
- st: g_seen (l: we don't want to see the same candidate again)
- st: start (l: where we start)
- st: end (l: where we end)
- b(g)
- l: 1 direction or bi-direction
- l: init first, later easy to push
- dfs
- l: hard interviews
- l: offer (l: 1. re nothing; 2. re overall* (re bit or re everything*); 3. re states)
- l: next candidate
- in edges loop; (l: 1. re nothing 2. re overall* (re bit or re every*) 3. re states)
- end edges loop (l: try everything, gave up)
- end dfs (l: dfs start at 1 point)
- motion:
- case: [[0, 1], [0, 2], [1, 2]] (each vertex connects each other)
- st: graph: {}
- st: g_seen: {}
- graph: 0 <-> 1; 0 <-> 2; 1 <-> 2;
- at dfs(0); end_x; g_seen_x; set_seen {0}; edges(1, 2) -> dfs
- at dfs(1); end_x; g_seen_x; ss {0, 1}; edges(0, 2) -> dfs
- at dfs(0); end_x; g_seen_*, re false, BT
- at dfs(2); end_*, re true, BT -> dfs(0), BT

- https://leetcode.com/problems/keys-and-rooms
- complex:
- simple:
- st: 2D [[1], [2], [3], []] (l: ind = where we start; vals = where we end)
- st: 1D [1, 2, 2] (l: ind = child; val = parent; employee and manager)
- dfs
- x
- dfs
- l: interviews
- l: offer
- l: other candiates
- l: 1. re nothing*; 2. re overall; 3. re states
- dfs(0) (l: dfs has a start point; 0 + rest rooms === seen so far === rooms.len)
- motion:
- case 1:
- [[0, 1], [0, 1, 2], [2], [3]]
- st: graph -> set graph; OR -> 2D graph; OR -> 1D graph;
- st: g_seen
- b(g)
- 0 -> 0, 1
- 1 -> 0, 1, 2
- 2 -> 2
- 3 -> 3
- t(g)
- 0 -> 0, 1
- 1 -> 0, 1, 2
- 2 -> 2
- 3 -> 3
- at 0 (seen_x; set_seen {0}; es(1, 2)) -> to 0 OR to 1
- at 0 (seen_*; re; BT)
- at 1 (s_x; ss {0, 1}; es(0, 1, 2)) -> to 0 OR to 1 OR to 2
- at 0 (re, BT)
- at 1 (re, BT)
- at 2 (s_x; ss {0, 1, 2}; es(2)) -> to 2
- at 2 (re, BT)
- now back at 1 (s_*; re; BT)
- now back to original 0 -> final -> seen: {0, 1, 2} !== rooms: {0, 1, 2, 3}
- 3 (never reach)

- https://leetcode.com/problems/water-and-jug-problem/description/
- complex:
- simple:
- global seen (l: !distinct ele, no remove; distinct ele, remove)
- max = jug1 + jug2 (l: max === everyone's max capacity)
- x
- dfs
- if water > max (l: inteview (bound))
- if water < ... (l: interview (bound))
- g_seen.has (l: interview (avoid same))
- l: offer (tar)
- g_seen.add (l: offer (avoid same))
- condi = dfs(|water-j1|) || dfs(|water+j1|) || ...
- l: gen paths: 1. dir; 2. edges; 3. arr; ... 4. ele diff VS ele merge
- start_func
- re dfs(|j1-j2|) (l: 1. re nothing; 2. re overall bit/every*); 3. re states)
- motion:
- case 1:
- j1 = 5, j2 = 3; target_water = 4
- physical, 5L full then pull into 3L; 2 left in 5L jug
- put 2 into 3L jug; 5L full then push 1 into 3L jug; 4 left in 5L jug
- st: g_seen: {water_key} (? stop loop)
- st: j1(5), j2(3)j, water
- 5-3=2; at 2 (tar_x; B_*; s_x; ss {2}; ...) -> (3-2=1) OR -> (3+2=5) OR -> (5-2=3) OR -> (5+3=8)
- at 1 (tar_x; B_*; s_x; ss{2, 1}; ...) -> (3-1=2) OR -> (3+1=4) OR -> (5-1=4) OR -> (5+1=6)
- at 2 (tar_x; B_*; s_*, re false, BT)
- at 4 (tar_*, re true, BT)
- back at 1, re true, BT
- back at 2, re true, finish

- https://leetcode.com/problems/network-delay-time/description/
- complex:
- simple:
- const graph = map() (l: node -> node; cycle)
- dist = new Arr(len+1).fill(inf)
- l: parallel universe store infos
- l: human starts with 1; natural starts with 0
- l: stand there 0; never reach inf
- dist[0] = -1;
- l: human starts with 1; antural starts with 0
- dist[k] = 0 (l: stand there 0; never reach inf)
- const q = []
- l: 1. dfs; 2. queue*
- l: water pipe needs water to run
- l: preprocess: 1. b(g)*; 2. sort
- v = t[i][0]
- e = t[i][1]
- d = t[i][2]
- l: between 2 pts, there is distance
- l: between 2 pts, there are infos
- if graph[i] === undef, assign [] (l: everyone has school bag, I don't have, buy, store books)
- q.push(k) (l: water pipe needs water to run)
- while q.len > 0, q.shift() (l: water pipe needs water to run)
- if graph[i] === und, con (l: in order to know end_node, must reach beyond)
- edge loop (l: gen paths: 1. dir; 2. edges*...)
- l: 1. dfs; 2. condi dfs*; 3. no dfs
- prev_dist + dist < curr_dist (l: everyone can reach this pt, but few can reach higher)
- dist[e] = dist[nodeInd] + tmp_dist (l: between 2 pts, there are infos)
- start_fnc
- max = max(...res)
- l: everyone can reach this pt, but few can reach higher
- motion:
- case 1:
- [[1_start, 2_end, 1_time], [2, 1, 1]] (cycle)
- st: graph: 1->2(1); 2->1(1)
- st: dist: [+, +, +] -> init [0, 0, +]; start at k=1
- st: queue: []
- at 1 (D1 = 0; [1]) -> to 2 (D2 = D1_0 + t_1 < D2_+; [0, 0, 1]_*; [2]_*)
- at 2 (D2 = 1; [2]) -> to 1 (D1 = D2_1 + t_1 < D1_0; [0, 0, 1]_x; [1]_x), end_queue
- max [0, 0, 1] -> 1

- https://leetcode.com/problems/path-sum-iii/description/
- complex:
- simple:
- st: count (l: life is up and down, goes on, but must have a few highlights)
- dfs_check_single_node (l: loop -> dfs (single dfs))
- check(node, sum) (l: as we go down, target is less and less, we are closer to the target)
- if node -> dfs (l: life hit the bottom, bounce back)
- == tar, ++ count (l: life is up and down, but must have highlights)
- check(left, sum-..) (l: as we go down, target is less and less, we are closer to the target)
- check(right, .......
- x
- tree (l: loop -> dfs(loop), but in recur form)
- if node -> check, tree(left), tree(right) (l: life at bottom, bounce back)
- l: loop -> dfs(single dfs)
- l: life is at curr state
- l: life goes left, what will happen?
- l: life goes right, what will happen
- x
- start_func (l: life start at some point, then all the way down; real life no backtrack, never)
- motion
- case 1:
- b(g); 4_top_root -> 4 (2 null) OR -> 4 (2 null); tar = 4
- t(g); FOR TOP 4: at 4_top (s = 4; end_x; tar_*; c=1) -> small_step (dfs) -4 -> at 4 (s=0; end_x; tar_x) -> at null (s=-4; end_*; BT)
- at 4 (s=0; end_x; tar_x) -> ss (dfs) -4 -> null (s=-4; end_*; BT)
- now back to 4_top_root -> ss (dfs) -4 -> at 4 now (s=0; end_x; tar_x) -> ss (dfs) -4 -> at null (s=-4; end_*; BT) -> back at 4 (...) -> at null (s=-4; end_*; BT)
- FOR LEFT 4 (s=4; end_x; tar_*; c=1+1=2) -> left null (s=0; end_*; BT) OR right null (s=0; end_*; BT)
- FOR RIGHT 4 (s=4; end_x; tar_*; c=2+1) -> left null (.. )OR right null (..)

- https://leetcode.com/problems/lexicographical-numbers/description/
- complex:
- simple:
- st: res: [] (l: need a pool to collect results)
- st: tar = 13 (l: need a target, so we know what to achieve and when to stop)
- dfs
- x
- dfs
- if curr > tar (l: strong checks befor offering)
- res.push(curr) (l: pass all strong checks, then offer)
- loop(i=0; i<10...) (l: curr*10+i -> gen all num in this sector -> gen more dfs path for next travel)
- end_dfs, loop(i=1, i<10..) (l: each iteration represents 1 sector, 1, 10, 12...; 2, 20..; finish 1 sector (dfs base return), then next sector
- motion:
- st: res: []
- st: tar = 13
- at null -> 1 OR 2 OR 3 OR 4 OR ... 9
- e.g. lexi order (same_scope_must_finish) === 1, 10, 100, 101, 102, 11; 2, 20, 200, 201, 202, 21...; 3, 30, 300, 31;
- 1 (B_*; tar_*, push) -> 1*10+0 (B_*; tar_*, push) -> 100 (B_x; BT)
- 1 (..) -> 1*10+1 (B_*; tar_*, p) -> 110 (B_x, BT)
- 1 (..) -> 1*10+2 (B_*; tar_*, p) -> 120 (B_x, BT)
- 1 (..) -> 1*10+3 (B_*; tar_*, p) -> 130 (B_x, BT)
- ..
- 1 (..) -> 1*10+9 (B_x, BT)
- 2 (B_*; tar_*; push) -> 2*10+0 (B_x, BT)
- 3 (B_*; tar_*; push) -> ... (BT)
- ...
- 9 (B_*; tar_*; push) -> ... (BT)

- https://leetcode.com/problems/house-robber-iii/description/
- simple:
- [lnr, lr] = dfs(node.left)
- l: bureaucracy (1) VS best of normal people (4)
- [rnr, rr] = dfs(node.right)
- l: .......
- below: 1. root + left + right (x); 2. ro + !l + r (x); 3. ro + l + !r (x); 4. ro + !l + !r (*); 5. !ro + l + r (*); 6. !ro + l + !r (*); 7. !ro + !l + r(*); 8. !ro + !l + !r (*); 
- !base_case (l: bureaucracy (1) VS ...)
- base_case (l: bur....)
- start_func
- l: dfs start 1. pt*; 2. str; 3. arr
- re = dfs(...) (l: 1. re nothing; 2. re overall bit/every; 3. re state*)
- motion:
- case 1:
- [1, 2, 3] -> root = 1, then 2, 3 are children
- at 1 
- 1. self_rob = self_rob(1) + left_not_rob(..0) + right_not_rob(..0)
- x
- 2. snr = snr(0) + lr(..2) + rr(..3) -> 5
- 3. snr = snr(0) + lr ..2 + rnr ..0 -> 2
- 3. snr = snr(0) + lnr ..0 + rr ..3 -> 3
- 4. snr = snr(0) + lnr ..0 + rnr ..0 -> 0
- 2-4 max = 5; return [1, 5] -> final max[1, 5] -> 5
- x
- now at 2 
- 1. sr .. -> 2
- 2. snr .. -> 0
- 3. snr .. -> 0
- 4. snr .. -> 0
- 2-4 max 0; return [2, 0]
- x
- now at left null
- return [0_rob, 0_non_rob]
- now at right null
- return [0, 0]
- BT
- now at 3 -> left and right null ...

- https://leetcode.com/problems/surrounded-regions/submissions/920993535/
- simple:
- dfs
- base_case (l: can we travel further?)
- l: travel, mark position
- l: 4 dir
- start_func (l: try luck, shortcut)
- l: preprocess: 1. b(g); 2. sort; 3. modify*
- 2D loop (l: 1. dfs travel; 2. brute travel*)
- l: 1. dfs; 2. condi dfs*; 3. no dfs
- l: country surround city
- x
- l: process (1. t(g); 2. modify*)
- l: bureaucracy canot be touched, but normal people get hurt

# read, write

- https://leetcode.com/problems/merge-sorted-array (\*)
- https://leetcode.com/problems/duplicate-zeros (\*, brute_force)
- https://leetcode.com/problems/sort-array-by-parity (\*)
- https://leetcode.com/problems/sort-array-by-parity-ii/ (\*)
- https://leetcode.com/problems/remove-duplicates-from-sorted-array (\*)
- https://leetcode.com/problems/remove-element (\*)
- https://leetcode.com/problems/move-zeroes (\*)
- https://www.geeksforgeeks.org/minimum-swaps-required-group-1s-together/
- https://poitevinpm.medium.com/leetcode-2134-minimum-swaps-to-group-all-1s-together-ii-a9a19d85d4f5

# swap

- https://www.geeksforgeeks.org/minimum-swaps-required-group-1s-together/ (\*)
- https://leetcode.com/problems/maximum-swap/ (\*)
- https://leetcode.com/problems/smallest-string-with-swaps/ (x)
- https://leetcode.com/discuss/interview-question/780698/got-this-in-an-interview-how-to-solve (x)
- https://leetcode.com/discuss/interview-question/1517196/Amazon-or-OA-2021-or-Hackerrank, find_min_swap (\*)
- https://leetcode.com/problems/move-zeroes/ (\*)

# Monotonic Stack

- https://leetcode.com/problems/daily-temperatures/ (\*)
- https://leetcode.com/problems/shortest-unsorted-continuous-subarray (\*)
- https://leetcode.com/problems/next-greater-element-i/ (\*)
- https://leetcode.com/problems/next-greater-element-ii/ (\*)
- https://leetcode.com/problems/online-stock-span/ (\*)
- https://leetcode.com/problems/132-pattern/ (\*)
- https://leetcode.com/problems/sum-of-subarray-minimums/ (x)
- https://leetcode.com/problems/largest-rectangle-in-histogram/ (x)
- https://leetcode.com/problems/sum-of-subarray-ranges/

# laser beam

- https://leetcode.com/discuss/interview-question/1669493/AMAZON-OA
- https://leetcode.com/problems/number-of-laser-beams-in-a-bank/description/ (\*)

# pt to orig

- https://leetcode.com/problems/k-closest-points-to-origin/

# paint fence problem

- https://leetcode.com/problems/paint-fence/, https://baihuqian.github.io/2018-07-29-paint-fence/ (x)
- https://leetcode.com/discuss/interview-question/1488281/Amazon-OA (\*)

# https://leetcode.com/discuss/interview-question/1655441/Amazon-or-OA

- it essentially asks for max length of subarray which can product one

A question about Amazon student badges but ultimately the problem was given an arr of -1 or 1, return the maximum subarray length with a product of 1.
The array is of size 2 and above and only contains -1 and 1
e.g arr = [-1,-1,1,1,-1], return 4, since index 0 to 3 have the max length with product equal to 1

I tried to use a sliding window but only passed 4/13 cases. there was somthing i had to fix in the logic for the case arr = [ -1,-1,-1,-1,-1, 1]

Given an array containing only 0 and 1 as its elements. We have to sort the array in such a manner that all the ones are grouped together and all the zeros are grouped together. The group of ones can be either at the start of the array or at the end of the array. The constraint while sorting is that every one/zero can be swapped only with its adjacent zero/one. Find the minimum number of moves to sort the array as per the description.
Example:
input array ={0,1,0,1}
Final array = {0,0,1,1}
Minimum moves = 1 (1 at index 1 is swapped with 0 at index 2)

input array = { 1101}
Final array - {1110}
Minimum moves = 1 {1 at index 2 is swapped with index 3}

I passed all test cases on this one 13/13.

I ran a sliding window to check number of swaps if the elements on the left should be 0s before 1s, and at each 0 found by right index, I found the number of swaps needed
repeated the same above for the case if the elements on the left should be 1s before 0s,
returned the minimum of both operations.

Do I have even a miniscule chance of moving forward

# https://leetcode.com/discuss/interview-question/1557009/amhttps://leetcode.com/discuss/interview-question/1557009/amazon-online-coding-assessment-sde-2

- https://leetcode.com/problems/valid-parentheses/ (\*)
- There are 3 rules for a valid string:

An empty string is valid
You can add same character to a valid string X, and create another valid string yXy
You can concatenate two valid strings X and Y, so XY will also be valid.
Ex: vv, xbbx, bbccdd, xyffyxdd are all valid.
I tried using recursion. but could not complete all test cases. Good approaches or solutions will be helpful.

# parentheses

- https://leetcode.com/problems/generate-parentheses/ (\*)
- https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/ (x)
- https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/ (\*)
- https://leetcode.com/problems/score-of-parentheses/ (\*)
- https://leetcode.com/problems/different-ways-to-add-parentheses/ (\*)
- https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/ (\*)
- https://leetcode.com/problems/valid-parenthesis-string/ (\*)
- https://www.1point3acres.com/bbs/thread-847941-1-1.html
- https://leetcode.com/problems/valid-parentheses/ (\*)

# retail

- https://leetcode.com/discuss/interview-question/1695225/Amazon-OA-or-Part-1-70-Min-or-SDE-Position
- https://leetcode.com/discuss/interview-question/1688875/Amazon-SDE1-or-Number-of-Retailers-who-can-server-given-requests

# product 1

- https://leetcode.com/discuss/interview-question/1692832/Amazon-or-Online-Assessmentor-Product-of-1 (\*)
- https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/ (\*)
- https://leetcode.com/problems/product-of-array-except-self/ (\*)
- https://leetcode.com/problems/maximum-product-subarray/ (look_for_val) (\*)
- https://leetcode.com/problems/sign-of-the-product-of-an-array (\*)
- https://leetcode.com/problems/product-of-the-last-k-numbers/ (\*)
- https://leetcode.com/problems/maximum-product-of-three-numbers/ (\*)
- https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array/ (\*)
- https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/ (\*)

# flip 1 dp

- https://leetcode.com/problems/flip-string-to-monotone-increasing/
