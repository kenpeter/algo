# bfs

- https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)

- https://leetcode.com/problems/subsets (\*)
- why we don't push ele in the dfs base / boundary check?
- why we push ele in the dfs loop?
- because we formt the path in dfs loop
- it is already formed, so no need to push ele in dfs base

- https://leetcode.com/problems/subsets-ii/ (\*)

- https://leetcode.com/problems/permutations (\*)
- why used arr is so good in dfs
- we can use path_arr.includes(ele) to achieve unique
- if there are repeated num, we know exactly who used / who not used
- for dfs loop, why i=0? why we re-scan from zero?
- because if i=start_ind, we skip / miss many elements
- we want to have all elements
- why not dfs(i+1, path)?
- because i+1 will skip many elements
- why used[ind] = true -> dfs -> used[ind] = false?
- because dfs in the middle

- https://leetcode.com/problems/permutations-ii (\*)
- why we have 2 ways to acc path?
- 1. in base / boundary check, path.slice(0), res.push(path)
- this is easiest, because we just copy
- but waste mem
- 2. we don't copy in base / boundary check, we use single path arr (global)
- path.push() -> dfs -> path.pop()
- save mem, but a bit confused
- why in loop, (i=0 && ns[i-1] === ns[i] && used[i-1] === true) con, is to use LAST ELEMENT?
- for last same ele, from 0 to last same ele, used[i-1] === false (always)
- so we can form its own unique path
- all prev same eles, are duplicated

- https://leetcode.com/problems/combination-sum (\*)
- why we cannot use ind >= arr.length, instead use acc_sum >= tar?
- because ind can be the same index, repeat again and again
- why we use same_dfs_i?
- because same num can be used to form sum

- https://leetcode.com/problems/combination-sum-ii (\*)
- in dfs loop, why we put i > start_ind in the con statement (curr and prev ele same same)?
- why not put loop(i=ind+1, i<arr.length)?
- or why not put loop(i=ind, i<arr.length-1)?
- because put i > start_ind in the con statement, we can use this single ele, this single ele will be pushed to path arr, it bypass the con statement
- why in loop, if(i > ind && ns[i-1] === n[i]) continue, why i > ind is to use FIRST ELEMENT?
- because i=ind, is to be used; later same ele skips

- https://leetcode.com/problems/palindrome-partitioning (\*)
- for func isPal(), why ++i and --j?
- because if i and j not move, inifinite loop
- why substring(start_ind, end_ind) become diff dfs path?
- because they are diff possible, diff path

- https://leetcode.com/discuss/interview-question/1625460/AMAZON-OA-Find-K-maximum-Priority


- https://leetcode.com/problems/factor-combinations (\*)
- why dfs_n decrease, while dfs_curr increases?
- because dfs_n is being consumed by mod
- because dfs_curr in each dfs loop, dfs_curr inc, to pass down, to maintain inc order in result
- why dfs_n === 1 is the base case?
- because dfs_n is being consumed by mod
- why for i=curr; i <= dfs_n?
- i <= dfs_n, because dfs_n is being consumed and eventually === 1



- https://leetcode.com/problems/palindrome-permutation (\*)
- why aaabb, then a = 3 freq, b = 2 feq?
- because permutation, we can move around, for all orders
- why map.set(key), then map.delete(key)?
- beause map.size will reduce
- then map.size <= 1, means palindrome

- https://leetcode.com/problems/palindrome-permutation-ii

- https://leetcode.com/problems/word-pattern-i (\*)
- why pattern and match_sub_str should have the same frequency at start?
- because all operations below, we assume pattern and match_sub_str to be same frequency, so the loop in same step
- why set store sub_str, not pattern_char?
- because mp(pattern_char, sub_str), map store the pattern_char
- why map and set are together?
- because e.g. map(a, b), map(a, c) these will never happen; beause b and c must be unique
- why map and set are in 4 combos?
- 1. seen in map, in set (con)
- 2. seen in map, not in set (return false)
- 3. not seen in map, in set (return false)
- 4. not seen in map, not in set (set, then con)
- because map and set together
- why 3 factors mp(pattern), set(pattern), mp.get(pattern) === income_pattern, to prove equal?
- mp(pattern) and set(pattern), never say sub_str equal or not
- so we need to have mp.get(pattern) === income_pattern
- why we return true at the end?
- because in the loop, we try to return false
- same as in loop we try to return true, but no way
- then last return false

- https://leetcode.com/problems/word-pattern-ii/ (\*)
- why p_ind done scan pattern, why s_ind done scan string?
- because if they are all done in same speed, so equal
- if they are in diff speed, then non-equal
- why 4 combo?
- because
- 1. seen, set
- 2. seen, !set
- 3. !seen, set
- 4. !seen, !set
- why no +1, s_ind -> s_ind + sub.len + 1?
- because e.g. abcd, start at b, bcd === 3 len, b + 3 len === over len, so no +1
- why we have diff dfs path?
- because p_ind and s_ind are in diff speed
- why set map, set -> dfs -> unset map, set?
- because dfs is in middle

- https://leetcode.com/problems/flip-game-i (\*)
- why in loop, i-1 and i together?
- because 2 consecutive chars to flip
- why sub(0, i-1) + (--) + sub(i+1)?
- because i === curr, i-1 === prev

- https://leetcode.com/problems/flip-game-ii (\*)
- why we start at i=1?
- because i === curr, i-1 === prev, so i starts at 1
- why we need to be care of var's scope?
- because if we have same var, we conflict
- because if not local var, we confuse var
- why we have a flip before dfs?
- because this is the player 1 flip
- because player 1 flip, then player flip
- why condi = dfs(curr_s) is the overall player 2 flip?
- because dfs represent the overall outcome
- why dfs prepresent overall outcome?
- because it goes down to all paths


- https://leetcode.com/problems/generalized-abbreviation (\*)
- in the dfs boundary check / base, why there is no curr_char?
- because end of str, there is no curr_char
- full = prev_str (sub_path_1) + counter (sub_path_2) + curr_char(sub_path_3, no)
- why counter === 0 or counter > 0?
- because if counter acc, then we have abbrev the chars, then c > 0; c === 0 means we have not used
- why we have only 2 dfs choices?
- becuase either counter acc or we convert the counter acc to str
- why?
- that is how the counter abbrev used
- why choice 1, prev_str (no change) + counter (inc) + curr_char (no change)?
- because counter acc
- why choice 2, prev_str (merge counter) + counter (merge to prev_str, and reset) + curr_char (merge to prev_str)?
- because counter converted
- why counter reset to 0?
- because the counter converted all

- https://leetcode.com/problems/android-unlock-patterns/ (x)
- https://medium.com/@rebeccahezhang/leetcode-351-android-unlock-patterns-d9bae4a8a958 (x)
- https://massivealgorithms.blogspot.com/2016/06/leetcode-351-android-unlock-patterns.html (x)
- https://cheonhyangzhang.gitbooks.io/leetcode-solutions/content/351-android-unlock-patterns.html (x)

- https://leetcode.com/problems/robot-room-cleaner/, https://wentao-shao.gitbook.io/leetcode/graph-search/489.robot-room-cleaner (\*)
- why no loop then dfs?
- because we don't even know the grid, we don't know the loop
- why start at dir=0, r=0, c=0?
- because we don't know where we start, then dir=0, r=0, c=0 is the choice
- why pass dir along r and c as param in dfs?
- because in the same r and c, each dir is diff; we need to diff them
- why no dfs check?
- there are 2 way to check: check before pass to dfs or check on top of dfs
- in this case, we check before pass to dfs
- why we call ro.clean() and set visited on top of dfs?
- because same reason, we check before pass to dfs
- why dir + i (the 4 dir)?
- because we keep rotating, dir + i is a way to rotate
- why (dir + i) % 4?
- because dir=0,1,2,3; i=0,1,2,3; dir+i=6 overflow, %4 keep in range
- why keep in range?
- because dir[ind], ind%4 in range
- why !seen and ro.move (detect we can forward), then dfs?
- because conditional dfs, we cannot just dfs
- why we need to revert the robot?
- beause if seen + ro.move, we physically move here, so we need to revert
- why whether dfs or not, we need to ro.turnRight()?
- because we need to move on another direction
- why we need to avoid global var and local var having same name?
- because global var and local var confuse each other
- const new_dir = (dir + i) % 4 === new_dir and new_ind
- because this contains dir, so new_dir
- because this contains %4, so it is new_ind, for arr


- https://leetcode.com/problems/campus-bikes-ii/ (\*)
- why min = +Infinity?
- because we need to assign smaller number, +Infinity can definitely get things going
- why I need a gobal_seen?
- global_seen[bike].add -> dfs -> global_seen[bike].del, for worker stable, bike loop
- why we need a 2D rem arr, init with -1?
- actually, we don't need them
- because there is code blow if rem[worker_ind][bike_ind] === -1, rem[worker_ind][bike_ind] = tmp_dist
- this is the only time we update rem[worker_ind][bike_ind]
- then dfs(this_dist + rem[worker_ind][bike_ind], worker_ind)
- it is same as this_dist + tmp_dist
- so we don't need rem[worker_ind][bike_ind]
- what is manhattan distance?
- manhattan_distnace = abs(x2-x1) + abs(y2-y1)
- similar to c^2 = a^2 + b^2
- on top of dfs, why tmp_dist >= min, early return?
- because it is shortcut, tmp_dist >= min, no use
- on top of dfs, why worker_ind >= ws.len, return min = min(min, xxx)
- because worker_ind finish
- why we loop bike?
- because it is a bike stable
- on top of dfs, why global_seen[bike_ind] === true?
- because bike_ind always starts at 0 again.
- why global_seen[bike_ind].add -> dfs -> global_seen[bike_ind].del?
- because 2 ways to use global_seen?
- 1. global_seen.add
- 2. global_seen.add -> dfs -> global_seen.del

- https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/ (\*)
- what is 1 and 0?
- 1 === block
- 0 === empty_path
- what is g?
- g === 2D grid with 0 and 1
- what is k?
- k === how much we can convert block to empty_path
- what is res?
- we start from (0, 0) to (m-1, n-1), how many steps
- what is this data structure?
- [row, col, k_so_far]
- normally is [row, col], but we have k here
- q = [[0, 0, 0]], why we init queue with single element?
- because while(q.len > 0), queue can start; q = [], queue cannot start
- why we need a global_seen?
- because we travel from (0, 0) to (m-1, n-1) in a 2D grid; k just extra
- why we need a 3D grid?
- because [row, col] this is normal, k extra -> [row, col, k_so_far]
- why global_seen[r][c][k+1], why k+1?
- because 0,1,2,3,4...; there are k+1 elements
- why global_seen[r][c][k_so_far] === true / false?
- because seen and !seen
- why normnally we need to init all data structure?
- 1. grid[r][c]
- 2. queue[r][c][k], init
- 3. global_seen[r][c][k], init
- because if we don't init, the process cannot start
- why these 3 data structure are very similar?
- because they are origin from grid[r][c], k just extra
- why the entire flow like this?
- queue_check -> dequeue -> 4_dir -> push_queue -> queue_check
- 1. queue_check === because we dequeue and push_queue, we don't know when finish; breadth level
- 2. dequeue === q.shift(), so the queue can eventually stop
- 3. 4_dir === (the future_row = row + row_d pattern)
- 4. push_queue === exhaust breadth level
- 5. queue_check === back to where we start
- what is loop(i=0; i<q.len; ++i)?
- loop(i=0; ...) === breadth level exhausting
- why future_row = row + row_d is the 4_dir dedicated pattern?
- because 
- future_row = row + row_id; future_col = col + col_d
- why put end check under queue_loop?
- because this is the 1st time we have row and col
- in the 4 dir loop,
- 1. boundary?
- 2. end point?
- 3. can dfs? (use k and !seen)
- (1) is it boundary?
- yes: continue
- no: next code
- (2) is it end point?
- yes: return res+1 (future point)
- no: next code
- (3) can dfs? (use k and !seen)
- why we cannot just dfs? why we need to put more condi to dfs?
- normally we don't travel the full dfs, we only go to certain dfs path
- what is use the k?
- 1. g[r][c] === 1, it is block -> next_k = curr_k + 1;
- 2. g[r][c] === 0, empty_path -> next_k = curr_k;
- what is seen and !seen?
- 1. seen === global_seen[r][c][k_so_far] = true, no dfs
- 2. !seen === global_seen[r][c][k_so_far] = false, dfs
- why put ++res after queue_loop?
- because queue_loop finish === breadth level scan finish, ++res
- why put return -1 after queue_check?
- because the overall breadth levels finish, so return -1

- https://leetcode.com/problems/brace-expansion/ (\*)
- why base check, ind >= str.len, then res.push(path)?
- because ind scan from left to right, end of str, now push result
- when res.push(path.join('')), why we need path.join('')?
- because path === [a,b,c], path.join('') === abc; we need string, not arr
- if(s[ind] === '{') and if(ind === '{'), why they are diff?
- s[ind] === actual char
- ind === the index, so diff
- why there are 2 dfs paths?
- e.g. a{b,c}
- 1. path1: a
- 2. path2: {b,c} -> it can become path2.1, b and path2.2, c
- why we need to scan { and }?
- because {a,b,c} -> [a, b, c] -> 3 dfs paths
- why there are 2 ways to copy dfs path?
- 1. path.push -> dfs -> path.pop; single path
- 2. path.slice(0) -> path1.push -> dfs; copy path


- https://leetcode.com/problems/stepping-numbers/ (\*)
- if lo === 0, res.push(0), why?
- because outerloop i=1 -> i=9, we don't want i=0
- why we don't have if hi === 0, res.push(0)
- lo === 0, res.push(0), enough, why need hi === 0, res.push(0)
- 
- on top of dfs, why curr > hi, return directly?
- because we need hi >= curr >= lo, curr > hi, out of range
- why hi >= curr >= lo, res.push(curr), why no return?
- because curr can gen more prev and next
- why res.push(curr), why curr has no repeated?
- because i=1 -> i=9, i is diff
- 
- why use curr to get last_digit?
- because (curr) and (curr % 10 - 1) are step number, desc releated
- curr*10 === left num; last_digit-1 === right num
- because (curr) and (curr % 10 + 1) are step number, inc related
- curr*10 === left num; last_digit+1 === right num
-
- why if last_digit > 0?
- because prev === next_curr in next dfs, it gets less and less, so last_digit > 0, keep it under control
- why last_digit === 0, cannot use?
- because e.g. prev = curr(0)*10 + last_digit(0) - 1 -> 0 + 0 - 1 -> -1 (not step number)
- why not curr > 0 -> dfs(prev)?
- because curr === 100, 99999, 1000000 very large num
- we want last_digit under control < 0
- similar why not curr < 9 -> dfs(next)
-
- why if last_digit < 9?
- beause next === next_curr in next dfs, it gets more and more, so last_digit < 9, keep it under control
- why last_digit === 0, cannot use?
- because e.g. next = curr(9)*10 + last_digit(9) + 1 -> 90 + 10 -> 100 (not step number)
- 
- why we finish dfs(prev) -> dfs(next)?
- because exhaust prev, until last_digit <=0, -> dfs(next)
- beause exhaust next, until last_digit >= 9, -> out of this func
-
- why outerloop i = 1 -> i = 9?
- why there is no i = 0?
- because i=0, handle by res.push(0)
- we don't want zero, e.g. prev = curr(0)*10 + last_digit(0) - 1 --> -1

- https://leetcode.com/problems/synonymous-sentences/ (\*)
- what is connect?
- [happy, joy]: happy -> joy
- or [happy, joy]: joy -> happy
- so 2 directions, forward and backward
- why 2 directions?
- [happy, joy]: happy -> joy, joy -> happy
- in graph, why the entry is hash, but the val is arr?
- because hash key === word, value === arr, allow easier to assign elements
- why we need to check graph[w1] === undef and graph[w1] === undef?
- 1. graph[w1] === undef, then graph[w1] === empty
- 2. graph[w1] !== undef, then graph[w1] === arr_with_element
- why loop sync?
- sync === [['a', 'b'], ['c', 'd']]
- e1 === ['a', 'b']; a, b connect
- e2 === ['c', 'd']; c, d connect
- why we need a queue here?
- the init queue is not empty, the while loop can consume it
- if the queue is empty, we cannot continue the rest of operations
- q = [str], we can start dequeue and process
- e.g. same 2D arr dp, with init, longest distance in 2D grid
- why we push entire str into init_queue_arr, const q = [str]?
- because queue_loop -> str -> word_arr -> edges
- why we need a global_seen here?
- because it is a graph, also it is bi-directions
- it is very easy to get into loop, in graph
- why we have 3 loops here?
- 1. str_queue loop ([str])
- 2. word loop (str -> word_arr)
- 3. edge loop (word -> edges)
- why we use while loop to loop queue?
- most of the time, we use while loop to consume queue
- because we don't know when it is finish
- also we will push elements into it, in while loop
- why we need to dequeue and get the str out?
- because the queue size will change (str = q.shift()) and while loop eventually stop (while(q.len > 0))
- in word_arr loop, graph[w] === undef, then continue, why?
- str -> word_arr, e.g. I and am, it is not in sync at all
- graph['I'] or graph['am'] has no entry, so graph[w1] === undef, continue
- we have word (vertex) -> replaced words (edges), why?
- because this what the sync for
- after graph[w] === undef, fail condi; then we enter graph[w] !== undef
- that means edges = graph[w], why?
- because graph[w] === undef -> empty; graph[w] !== undef -> have edges
- why word_arr[i] = replaced_word?
- because [joy, happy]: joy -> happy, happy -> joy
- also word_arr.join(' ') will form new string with replaced word
- why !global_seen.has(new_str) -> we push to queue.push(new_str)?
- if we seen it globally, then we must not process by adding to the queue
- why we don't do global_seen.add(new_str), after !global_seen.has check?
- because we follow natural flow, check on top of dfs


- https://leetcode.com/problems/maximum-number-of-accepted-invitations/ (\*)
- why row len === boy?
- because boy in row
- the single boy invite girl
- why col len === girl?
- because girl in col
- why there are 3 data structure?
- global_match === global girl boy matching state
- local_seen === this boy, this dfs
- grid[boy_ind][girl_ind] === can invite girl or not
- why use local_seen for each dfs travel?
- because outerloop -> dfs
- why use 1D arr for global_match and local_seen?
- because the ind === girl, value === boy; 1D arr is enough
- why all girl slot set to false?
- seen === true, !seen === false
- why we use n (girl_ind) as arr_len?
- why not use m (boy_ind) as arr_len?
- because e.g. there are many girls, not enough boys, so there are empty girl slot
- there are not enough girls, too many boys, so the girls are full
- why global_match[girl_ind] = boy_ind has to be global?
- because global_match[girl_ind] ~= global_seen, it holds the entire state of matching
- why not use global_match[boy_ind] = girl_ind?
- no beause local_seen[girl_ind] and global_match[girl_ind], they have consistent format
- why use -1 for the global_match?
- 1. global_match[girl_ind] === -1 (still in init stage)
- 2. globa_match[girl_ind] === boy_ind (already assigned)
- why there is no base check here, on top of dfs?
- we have global_match and local_seen checking within girl loop
- boy_ind cannot assigin into global_match[boy_ind], local_seen[boy_ind]
- why loop girls in dfs?
- because boy invites girl, in outerloop
- now girl loop in dfs
- boy_ind passed as param, stable, girl_ind loop
- why girl_ind starts at 0?
- because the dfs param, curr_boy_ind or prev_boy_ind, we loop the girl from start
- so we can re-do all girls for boys
- in the girl loop:
- 1. can we invite a girl? (most obvious)
- yes, g[boy_ind][girl_ind] === 1, next condi check
- no, g[boy_ind][girl_ind] === 0, next iteration
- 2. have we seen this girl? (most obvious)
- yes, seen this girl in this dfs, next ieration
- no, have not seen this girl in this dfs, next condi check
- 3. can we assign this boy to this girl? (assign)
- yes, global_match and local_seen assign, out directly, because ++res
- no, we cannot assign global_match and local_seen, next code (switch global_match)
- why we get out directly?
- because we don't want to switch global_match
- also condi === true, ++res
- why local_seen[girl_ind] = true, before dfs?
- because local_seen[girl_ind] = true ~= block after all checks
- if we don't seen now, go to dfs, we will hit this girl again, in same dfs
- 4. so current entire matching state is no good, can we change the entire matching state, 1 by 1
- why dfs(global_match[girl_ind] === prev_boy_ind) is called switch?
- because global_match[girl_ind] === prev_boy_ind
- so we restart from prev_boy_ind and redo from there
- if can_switch -> global_match assign -> local_seen assign -> return true
- why return false should after girl loop?
- because we put within girl loop, just return and skip many iterations
- normally return true after girl loop

- https://leetcode.com/problems/minimum-number-of-lines-to-cover-points/ (\*)
- why need pt1?
- because cal_slope(pt1, pt2)
- why need pt2?
- because cal_slope(pt1, pt2)
- why we need to care point 1 === point 2?
- pt1 === pt2, large infinity slope, not usable
- pt1 !== pt2, we have slope to use, usable
- on top of dfs
- 1. have we exhausted all pt_arr?
- pt_arr.len === 0, return line.len
- pt_arr.len !== 0, we need to use existing line_arr to cover
- why use line_arr to cover first pt?
- why not cover last pt?
- possible we can, but use 1st pt
- yes can cover first pt -> line_arr loop -> compare_slope -> return dfs(pt_arr_1_less, line_arr)
- no cannot cover first pt -> loop pt_arr -> form new slope -> dfs(pt_arr_i_less, line_arr_inc)
- 2. no we have some ele in pt_arr; loop line_arr -> compare_slope -> dfs(pt_arr_1_less, line_arr)
- why first_slope === curr_pt_slope -> return dfs(pt_arr_l_less, line_arr)?
- why we need to return?
- if no return, we stay in pt_arr loop; after loop finish, we enter pt_arr, which we don't want
- line_arr cannot cover first pt
- we have a shortcut: if pts.len === 1, return line.len + 1, why?
- because shortcut
- why this also an early return?
- because same reason, we don't want to enter pt_arr loop
- why min line to cover 1st pt?
- because min = dfs(pt_arr_i_less, line_arr_inc)
- each iteration of pt_ar === 1 dfs decision
- 3. line_arr loop: line_arr cannot cover 1st pt, loop pt_arr -> form new slope -> dfs(pt_arr_i_less, line_arr_inc)
- pt_arr_i_less === pt_arr remove i
- line_arr_inc === line_arr.push([pt_i, pt_i_slope])
- why line_arr.push pt_i, not first_pt?
- because pt_arr we remove pt_i, line_arr, we inject pt_i

- https://leetcode.com/problems/nested-list-weight-sum (\*)
- why we pass arr and depth as param in dfs?
- because arr === branch
- because or arr === leaf
- arr is changed in each dfs level
- why arr is changed, because into each dfs level, arr is diff
- why we need depth?
- because sum = sum + ele.getInt() * depth (here)
- why we have a res before the arr loop?
- e.g. [1, 1], 2, [1, 1]
- [1, 1] === sub result
- 2 === sub result
- [1, 1] === sub result
- why we loop arr?
- e1 === [1, 1], e2 === 2, e3 === [1, 1]
- so it can be leaf or it can be branch
- here, we have 3 decisions
- in arr loop, ele = arr[i], why ele can be leaf or branch?
- [1, 1] === branch; 2 === leaf
- why res is acc?
- sum1 = [1, 1], sum2 = 2, sum3 = [1, 1], add up together
- so res = res (prev sum1, sum2) + sum3
- why pass arr and depth + 1 for next dfs level?
- because pass arr, we can get arr === leaf or branch
- depth+1 is for next level, res = res + getInt() * depth 

- https://leetcode.com/problems/nested-list-weight-sum-ii (\*)
- why max depth === 1?
- why not max depth === 0, because [[]], this maxDepth === 0?
- the test case so far is [1, []], 1 <= list.len <= 50, so at least 1 ele
- so max depth === 1
- why [1, []] this depth === 1, not 2??????
- because e1 === 1 (depth === 1), e2 === [] (dfs will go down, we don't know the depth yet)
- e2 === [], into the next dfs level, there is a loop, but update the depth is within loop
- [] cannot get into loop -> cannot update depth, so depth === 1 (for e1)
- it is a leaf (end) and branch (arr)
- ele.isInteger() !== ele.getInteger() 
- ele.isInteger() --> is it an int, checking
- ele.getInteger() --> return int, actual thing
- why maxDepth is the global, not within dfs?
- because maxDepth needs to be stable, and maintained
- if put maxDepth within dfs, it will overwrite
- if ele.isInt() -> max(maxDepth, depth), why I need to compare depth, even 
- when ele.isInt() is there, e.g. [e1, e2, e3], so we never get into the else to dfs
- so we need max(maxDepth, depth) to update maxDepth
- for curr_arr loop, 
- all the ele * weight and dfs are within loop
- curr_arr.len === 0, no loop, will not get into ele * weight / dfs, no update depth
- why we don't do dfs(ele.getList(), depth + 1) * weight?
- dfs(ele.getList(), depth+1) === all elements result (weight for single element), if all_elements_result * weight, nono

- https://leetcode.com/problems/different-ways-to-add-parentheses/ (\*)
- why given str, then directly dfs?
- given str (start dfs level), then put diff brackets (diff brackets -> diff dfs sub path)
- why we need a global map?
- key: str, val: [e1, e2]
- because we cache / dfs
- what is str param passed down?
- e.g. 2-1-1; 2-1; 1
- it is always full cal form, never has -2 or 2-
- because we split +, -, *, left out === full cal form
- why we don't have a base check?
- res is like the base check
- 1. res = [] -> str is num -> [str_num]
- 2. res.len > 0 -> into_split_loop -> [e1, e2]
- res.len === 0, we did not get into split loop
- res.len > 0, we get into split loop
- why res = []?
- res = [] -> str is num -> [str_num]
- res.len > 0 -> into_split_loop -> [e1, e2]
- why we need to loop char by char?
- we need to get symbol +, -, *, why?
- so we can split and get the full cal form
- e.g. 2-1-1 (init dfs) -> (2-1)-1 sub dfs -> 2-(1-1) sub dfs
- so this dfs has 2 paths
- in the split loop, what is left_res and right_res
- left_res = [], [e1, e2]
- right_res = [], [e1, e2]
- why we need left_res and right_res?
- because left_res === cache or dfs
- because right_res === cache or dfs
- why we don't return directly if see cache?
- normally, if get cache, we should return, but here diff
- left_res is for later 2D loop
- right_res is for later 2D loop
- why cache / dfs -> then cal result?
- why not cal result -> cache / dfs?
- because dfs is bottom up
- we hold the result, hit the bottom, cal from bottom, then keep returning
- why left_res and right_res are array?
- because 2D loop, i stable, j loop
- in the 2D loop, why we put res.push within the 2D loop?
- why not after 1st inner loop, why not after outerloop?
- beause we need each of the result
- why the sum = e1 + e2, why we don't do sum = sum + (e1 + e2)?
- because we are not acc.
- if we don't ask why, then we blindly follow pattern

- https://leetcode.com/problems/longest-increasing-path-in-a-matrix/ (\*)
- why we need 2 max: outerloop max and dfs max?
- outerloop max: max after each full single dfs path
- dfs max: each sub dfs path (4 directions -> 4 decisions)
- outerloop max and dfs match both need
- why use index = i + '_' + j?
- because if we have the cell index, mp.get(ind) === min_dist_so_far
- on top of dfs
- 1. check boundary
- why return 0?
- we return -1, 2,3,4, '', [], because min_dist so return 0
- 2. hit block in middle
- for this leetcode, hit block in middle ~== water flow (pacific, atlantic flow)
- we flow backward, high to low
- 3. other condi?
- 4. seen?
- we put the seen in last place, why?
- because if we put seen before descending condition check, we ignore the descending condition
- must satisfy all necessary conditions before the seen.
- seen just blindly return, when saw it
- why use global_seen, not local_seen?
- because it is global path travel, we may hit the same cell again and again
- also we need to use global_seen as cache, global_seen.get(ind) === min_dist_so_far
- 5. block after all check?
- no need, as we don't modify the cell
- 6. operation?
- 7. 4 dir
- for the 4 dir, why we do r1, r2, r3, r4?
- because r1 = dfs(xxx), r2 = dfs(xxx), r3 = ..., r4 = ...
- max = 1 + max(r1, r2, r3, r4)
- each r1, r2, r3, r4 === sub dfs max
- why we need to have +1 here?
- because the base dfs return 0, if no +1 here, we are not able to acc


- https://leetcode.com/problems/accounts-merge/ (\*)
- https://leetcode.com/problems/accounts-merge/discuss/494151/JavaScript-Solution-DFS
- for graph, why we use hash, rather than map?
- we can use use map, but hash is mush eaiser to assign vertex and assign arr/set to the end
- why we use global seen, in dfs travel; why not use a local seen?
- because when we travel, we want to hit the cycle; when it is cycle
- it means we stop and this dfs path is done, and return sub result to prev dfs
- why we have dfs in outerloop, then within dfs we have another dfs?
- because outerloop, we init the dfs
- within dfs, we need to dfs need to self travel
- within outerloop, return_email_arr = dfs(email), why return_email_arr can be []?
- because prev dfs travel may hit this email (vertex), so we hit again, we return []
- within outerloop, why we sort the email_arr?
- because looks nice and question asks
- within outerloop, why we unshift person_name to start?
- because question asks
- why we use first_email as vertex, then conenct rest of emails?
- why not do N^2, each node connect with each other once
- because we know that first_email is in the same boat as other email in arr
- It is representative, this also avoid N^2
- then why rest_email connects first_email only?
- this is the same idea that first_email as vertex, connect to rest_emails
- rest email only connects back to first_email
- why in same_arr, we form cycle; why in diff email_arr, same vertex can appear, hence edges inc?
- because some arr processes 1st, then other arr processes later
- why graph like this?
- [a]; a->x (no edge)
- [a, b]; a->b, b->a (cycle)
- [a, b, c]; a->(b and c); (same_arr, more set)
- [a, b], [a, c]; a->(b and c); (diff_arr, same vertex)
- why we need a name_hash?
- because name_hash[email] = person_name, so diff email as key entry, will have same person_name
- when build graph, why we check graph[curr_email] === undefined, then graph[curr_email] = new Set()?
- because later we do graph[curr_email].add(ele), without new Set() before, this is invalid add operation
- this allows natural operation
- when build graph, when forming a cycle, why we don't need j === 1?
- because j === 1, it is 1st email; it has vertex, but it has no edge
- why for edge we use set, not arr?
- because edge can be repeated, arr allows repeated, we don't want repeated.

- https://leetcode.com/problems/number-of-islands (\*)
- why "1" and "0" in question?
- because question asking, we are not using 1 and 0
- on top of dfs
- 1. bounday check
- 2. hit block in middle
- 3. other condi?
- 4. seen?
- 5. block after all check
- 6. operations
- 7. 4 dir

- https://leetcode.com/problems/max-area-of-island (\*)
- why standard 2D loop?
- because flood-fill
- 2D loop -> g[r][c] === 1 -> dfs -> max -> area = 0, why?
- 2D loop (flood-fill) -> g[r][c] === 1 (init cell) -> dfs (rest cells) -> max (after 1 dfs result) -> area = 0 (reset)
- on top of dfs
- 1. check boundary
- 2. block in middle
- 3. other condi?
- 4. seen?
- 5. operations
- 6. 4 dir

- https://leetcode.com/problems/making-a-large-island/ (\*)
- why max = 0?
- it can be -1, -2, but 0 is enough, because we don't any max area
- later max = max(max, area)
- why set area = 0?
- for each area, we will label it and has area
- eventually, we connect 2 islands, to make largest
- why island label starts at 2?
- because 0 empty path, 1 is island, 2 is ready to use
- why we need a global_map?
- map.set(island_label, area_value), so each island has own label and own area
- why we don't put a global seen here?
- because it is a 2D loop when processing
- when travel, 2D loop -> new seen -> 4 dir loop
- we don't need a global_seen, but we need a local_seen before 4 dir loop
- 
- process: on top of dfs
- 1. check boundary
- 2. hit block in the middle
- why not use g[r][c] === 0?
- because g[r][c] === 0
- g[r][c] === 2,3,4,5,etc
- only when g[r][c] === 1, can connect other cells
- 3. other condi, no
- 4. other condi
- 5. operations
- ++area
- g[r][c] = label, why?
- because it indicates the cell belong to this label
- 6. 4 dir
- in outerloop of this dfs
- it is a 2D standard loop
- get in if g[r][c] === 1 -> dfs -> ++label (next island) -> area = 0 (reset)
- 
- travel: right inside the 2D loop
- why we use g[r][c] === 0, connect 4 directions?
- because g[r][c] === 0, turn g[r][c] === 1
- or g[r][c] === 2,3,4,5,etc (there is no g[r][c] === 1 any more)
- if g[r][c] === 0 -> new seen -> 4 dir loop (seen.add) -> reset seen, why new seen here?
- 1. connect 2 islands (2 directions)
- 2. connect 3 islands (3 directions)
- 3. connect 4 islands (4 directions)
- so we need a new seen here
- why area = 1?
- because we get in, g[r][c] === 0, turn g[r][c] === 1
- why 4 dir loop, we must have row_d and col_d?
- because we move future cell; row = curr_row + row_d; col = curr_col + col_d;
- 1. check boundary
- why no return here? because it is dir loop, not dfs
- 2. hit block in the middle
- mp.has(g[r][c]) === we have this island
- !mp.has(g[r][c]) === we don't have this island at all ~== g[r][c] === 0
- why?
- because there is no g[r][c] === 1 any more, only 0, 2, 3, 4, etc
- 3. other condi
- seen.has(g[r][c]) === we hit same island again
- we need to avoid, because later we have area = area + mp.get(g[r][c]);
- 4. block after all check
- seen.add(g[r][c]), seen this island
- 5. operations
- area = area + mp.get(g[r][c]), have 4 directions
- why max after 4 dir loop?
- because if put within 4 dir loop, we cannot
- 1 empty cell can connect to 4 directions, must after dir loop
- why at the end of entire fuc, return max ? max : m*n?
- because there is a chance that no 0 at all, so m*n
- how to diff same var name in same scope?
- e.g. using i, j, k in the same scope, very easy to overwrite each other
- so using curr_i, curr_j, curr_k

- https://leetcode.com/problems/shortest-bridge/ (\*)
- what is r1?
- r1 store all the 1st island i, j
- r2 store all the 2nd island i, j
- what is count = 0 vs count = 1?
- init cell -> rest cells
- 1st island, count = 0
- 2nd island, count = 1
- on top of dfs
- 1. check boundary
- 2. hit block in middle
- 3. other condi (no)
- 4. seen?
- 5. operation
- 6. block after all check
- 7. 4 dir
- why for graph: build graph -> process graph?
- paint island -> process island
- build graph -> process graph
- why min = Infinity?
- because anything assign, min is sure min
- why dist = abs(r2-r1) + abs(c2-c1) - 1?
- because c^2 = a^2 + b^2
- -1 because is like time - 1
- we have a bit more

- https://leetcode.com/problems/count-sub-islands/ (\*)
- what is g1 and what is g2?
- g1 === g2 in same shape, g1 some areas include some areas in g2
- 1. cell_1 = 0, cell_2 = 0, common empty, but no island, IGNORE
- 2. cell_1 = 0, cell_2 = 1, cell_2 extra, 1st travel remove it, LEFT OUT IS COMMON (del init_cell, surrounding cell removed as well)
- 3. cell_1 = 1, cell_2 = 0, no use for cell_2, IGNORE
- 4. cell_1 = 1, cell_2 = 1, commmon island, dfs g2 will count
- why we need to have 2 dfs travel?
- graph: build graph (easier process) -> travel graph
- flood-fill: paint 1st time (easier process) -> paint 2nd time
- graph ~= flood-fill
- why in outerloop, check g1[r][c] = 0, g2[r][c] = 1?
- cell_2 got extra, if remove, left out is the island we need
- for this g1[r][c] = 0, g2[r][c] = 1 init cell, once start, all surrounding cells removed
- we don't even need to wait for the 2D loop to advance, it is clean up by surrounding
- on top of dfs,
- 1. check boundary
- 2. if block in the middle
- 3. other condi (no)
- 4. seen? (2D loop, stable)
- 5. operations (no)
- 6. block after all check
- 7. 4 dir

- https://leetcode.com/problems/find-all-groups-of-farmland/ (\*)
- why do I need to know maxRow, maxCol?
- this is for a single travel in outerloop
- because farmland is rectangular --> the up width === down width, left length === right length
- if we know the max i and max j in dfs travel, we know max width and max length
- when push result [start_i, start_j, max_row, max_col]
- the top of dfs check?
- 1. check boundary
- 2. block in middle check
- 3. other condi?
- 4. seen?
- 4. block it all check pass
- 5. do operations, set max (*) / push result / etc
- in outerloop, why we have to check if g[r][c] === 1 -> dfs?
- if without g[rc][c] === 1 -> dfs, then dfs just randomly travel
- why maxCol = 0 -> dfs -> res.push?
- because after dfs, all things got updated, and we get result

- https://leetcode.com/problems/web-crawler (\*)
- why startUrl.split(/)[2]?
- http://abc.com -> (1) http: (2) '' empty str (3) abc.com
- why we need a domainName at the start of entire func?
- it is like leetcode paintColor, neighbour color (flood-fill) to be the same
- why we need res = []?
- res.push(url)
- why we need a global_seen?
- because it is a graph travel, may hit the same node again and again
- on top of dfs, check
- 1. has same domainName?
- 2. global_seen?
- 3. other condi?
- block it after check
- why we push result after all checks?
- res.push(url)
- because all condi pass, should push result
- what is htmlParser.getUrls(url)?
- it is like vertex -> edges
- startUrl === start vertex
- htmlParser.getUrls(startUrl) === edges

- https://leetcode.com/problems/number-of-distinct-islands/ (\*)
- we have shape_seen, why we don't have a global_seen or local_seen?
- because global_seen or local_seen, we use i + '_' + j, to avoid hit the same cell again and again
- for this one, it is not path finding and we have a stable 2D loop
- also the entry: dir + up + down + left + right
- what are the condi check on top of dfs?
- 1. boundary check
- 2. other check: hit block in the middle
- 3. seen check (no global_seen or local_seen, ignore)
- 4. block it after all checks: g[r][c] = 0, to avoid loop
- for condi check, why we return 'o'?
- should we return '', zero, [], etc? we need to return something representation invalid
- so all condi return 'o'
- why I need to do dir + up + down + left + right for the island?
- island A === island B, when !rotate and !translate
- it is current_dfs_direction + 4_future_dfs_directions, why?
- 4 directions, the position is fixed, why we need a dir as well?
- because bottom of dfs return -> o + o + o + o (cannot diff) -> dir + o + o + o + o (can diff)
- it is like we are in a cell, curr dir + 4 directions
- why init cell -> rest of cells -> after done, this is result?
- because this is a standard flood fill
- why do we put an init direction in outerloop, for dfs?
- because at start, we cannot put up, down, left, right, so put x
- how many directions do we have?
- 1. x + o + o + o + o
- 2. x + up + down + o + o
- but this is just 1 dfs level
- multiple dfs levels -> xooooooordloo.... can be long
- why we cannot have let res = 0 -> ++res in 2D loop -> return res?
- because there are repeated islands, that is why we need dir + up + down + left + right, then put into set.add

- https://leetcode.com/problems/swim-in-rising-water/ (\*)
- why global_seen acting like a local_seen?
- when global_seen.clear() in each loop, it is like a new seen, so local_seen
- why convert 2D arr into 1D arr?
- e.g. last_cell = n*n-1
- e.g. curr_cell = row_num * i + j
- this is very easy to do set.add(curr_cell = row * i + j)
- on top of dfs, why we check conditions like this?
- 1. boundary check
- 3. other condi check e.g. empty_block, g[r][c] > time (time is not ready to flow)
- 2. seen check
- because we check easier condi, then more difficult condi
- why condi -> g[r][c] > time, then return?
- time (0, 0) -> g[r][c], it time (0, 0) flows to g[r][c], not g[r][c] -> time (0, 0)
- g[r][c] is the prev dfs level, become this future cell. g[r][c] > time, it means time is not ready yet
- why there a pattern: diff condi check on top of dfs -> then we block the condi?
- e.g. seen.has ... return -> seen.add(vertex)
- because pattern: check -> block
- in the outer loop, why we use while loop, instead of i j loop?
- because we need to reach last cell, we don't know when we can reach last cell
- so we need while loop
- in the outer loop, why global_seen.clear()?
- because global_seen act like a local_seen
- why dfs(0, 0) in outerloop?
- because each time we re-start
- why ++time in outerloop?
- time ~= height, height inc
- at last return, why time-1?
- not sure, because time = 0 at start, then it should start at 1?
- when do we use global_seen or local_seen?
- it is when we need to use entry: i + '_' + j, cell entry
- if it is like shape of island: dir + up + down + left + right, then we 
- don't use global_seen or local_seen, we use shape_seen
- why we have to use seen is that, we will hit the same cell again and again
- because it is path searching

- https://leetcode.com/problems/the-maze (\*)
- why we don't have a global_seen / local_seen here?
- because robot will move forward / backward, so same cell may be visited again and again
- if we put global_seen, we may ignore many paths
- why we have a distance 2D arr?
- this uses the same method as maze 2
- each cell store the overall min distance, we reached so far
- why we store overall min distance?
- because when we reach the final destination, we have a final min distance
- we don't have any acc min distance (like campus bike), so we have to store
- final min distance
- why init each cell with infinity?
- when assign 1st value into dist array, we ca certainly assign value into it
- if we init 9999, that is not good
- if we assign -infinity, that means we store max distance
- why we assign start position in dist dp array, with 0?
- because start position has distance === 0
- if we don't assign 0, then dist[r][c] === infinity, then dist[r][c] + x, not possible
- on top of dfs, why there is no base check, condi check etc, why?
- later we have forward -> future_move_loop (boundary check in loop) -> backward
- because we check boundary + empty_block in future_move_loop
- in the 4 dir loop, why const row = start[0] + d_row
- because we steal a future move
- later forward -> future_move_loop -> backward
- why we cannot use const for row, const row = start[0] + d_row?
- why need to sue let row = start[0] + d_row?
- row = row + d_row, if row === const, how do we row cc
- why before the move_future_loop, we set let count = 0?
- count === count_step === each_block_move
- forward (steal future move, count +1) -> future_move_loop -> backward (count -1)
- forward / backward cancel each other, so count = 0
- why in future_move_loop, we have boundary check and empty_block check?
- because any thing block the movement, need to check
- 1. boundary will block movement
- 2. block in middle will block movement (g[r][c] === 1, block)
- g[r][c] === 1, block; g[r][c] === 0, empty_block
- why in future_move_loop, we have r = r + row_d?
- because we acc the move
- i.e. we lock 1 direction, then we keep moving that direction
- why ++count in future_move_loop?
- same reason, lock 1 direction, then we keep moveing that direction
- why we don't put dfs into future_move_loop?
- 4 dir loop -> future_move_loop, then dfs; why put dfs after future_move_loop?
- there are 2 ways to do direction dfs
- 1. each dir iteration -> dfs -> each dir iteration - dfs
- 2. or each dir itration -> future_move_loop -> dfs (*)
- why we need to backward after future_move_loop?
- because forward (count +1) -> xxx -> backward (count -1), cancel out
- why when count (acc) + dist[this_dfs_start_row][this_dfs_start_col] < dist[final_future_row][final_future_col], then we do assign full distance and dfs?
- count (acc) + dist[this_dfs_start_row][this_dfs_start_col] >= dist[final_future_row][final_future_col], >=, there is no value to assign and travel again
- as it is not min any more

- https://leetcode.com/problems/the-maze-ii (\*)
- see the maze i
- if there is no init, dist[start[0]][start[1]] = 0,
- none of the calulation will work
- because dist[start[0]][start[1]] = infinity

- https://leetcode.com/problems/flood-fill (\*)
- why color click !== bucket fill, we take no action?
- because there is no dfs, then we don't want to go down
- color === bucket fill, we want to go down with dfs
- why we need to remember the color we click?
- the color we click is called neighbour color color
- which all same neighbour color should be painted with new color
- why there are 3 diff colors?
- g[r][c] === curr_color, it may diff from neighbour_color and paint_color
- neighbour_color === same color in the same area
- paint_color === we want new color for this area
- what is the color relationship?
- g[r][c] === neighbour_color, we are in the same area, can paint new color
- g[r][c] !== neighbour_color, not in same area, cannot paint new color
- g[r][c] === paint_color, local_seen, return, to avoid loop
- g[c][c] !== paint_color, so can paint
- why pass neighbour_color into dfs func?
- so we know the next dfs level, g[r][c] is the same neighbour


- https://leetcode.com/problems/pacific-atlantic-water-flow/ (\*)
- what is pArr (pacific), aArr (atlantic)?
- pArr === local_seen
- why we don't modify the cell?
- there are 2 ways for local seen
- 1. modify cell
- 2. a copy
- here we make a copy, because we have pacific and atlantic, 2 diff
- on top of dfs, why we don't return anything
- return 0, '', [], none of them
- because if pArr[i][j] === aArr[i][j], that means common cell, common ground, return
- on top of dfs, why cannot flow, we need to return?
- because we need to flow high to low
- why flow high to low?
- 2 ways to paint: equal cell or descending / ascending
- here we using descending
- I don't think we can flow low to high
- on top of dfs, why we seen it, we return?
- to avoid loop, either modify cell or a copy; use a copy
- in the 4 direction pass to dfs, why pass arr into dfs?
- that is the local_seen, pArr / aArr.
- we are using same dfs func for pacific and atlantic, so use arr
- why we use current cell height as max, for current dfs? why not use same maxHeight for entire flow?
- because as we flow, we have 2 diff dfs level to flow; the height is diff in each dfs level; we cannot use same max height
- hence each dfs level is diff
- when paint grid, why we only go top and left?
- because that is for pacific
- when paint grid, why we only go right and bottom?
- because that is for atlantic
- why we don't do a 2D loop, then loop each cell?
- because base on the diagram, top and left === pacific, the init cell
- right and bottom === atlantic, the init cell
- for the init dfs, why we use -Infinity as maxHeight?
- because we want the first cell to flow and act like a maxHeight, no matter what
- why we use 2D loop for each cell, pArr[i][j] === aArr[i][j], to detect commont ground?
- because both seen it then it means both flow, hence common ground

- https://leetcode.com/problems/battleships-in-a-board/ (\*)
- why for flood-fill, we need to use standard 2D loop?
- because init cell -> all connected cells paint
- will not touch other areas
- why in the 2D loop, we need to check empty cell?
- because init cell -> all connected cells paint
- will not touch other areas
- why in the 2D loop, we ++res?
- because init cell -> all connected cells paint
- so that is the whole area === result
- why we check boundary on top of dfs?
- because future cell can travel or not
- why we check empty cell on top of dfs?
- because future cell can travel or not
- in the boundary check / empty_cell check, why return nothing?
- because we paint cell === result count
- what u want me return, 0, '', [], none
- why we modify the cell?
- paint the cell, we don't want to hit again global_seen
- why 4 directions?
- future cell can travel or not


- https://leetcode.com/problems/course-schedule/ (\*)
- why we detect the cycle in outerloop?
- because if 1 iteration is cycle, then return false
- if the outerloop does not return, we have a final return after outerloop
- this is typical pattern
- why we init local_seen at each iteration, in outerloop?
- because we have an outerloop here; it manages its own dfs path
- why I don't detect global_seen.has, local_seen.has in outerloop?
- because we have it detect within dfs.
- again, 1 iteration fail, return within outerloop;
- finisih all iterations, return success at the end
- when build graph, why we can have 2D arr or hash?
- because there are 2 ways to build graph; 2D arr === hash
- why the graph is 1 direction?
- because [0, 1], if do 0 then 1 must do first, 0 -> 1
- we cannot go 1 -> 0 in graph, that is not the question asking
- why local_seen === cycle, global_seen === avoid_loop?
- local_seen === cycle, because it is in own dfs path, we hit again
- global_seen === avoid_loop, because it is in entire dfs path
- why we do: local_seen.add -> dfs -> local_seen.del?
- because node in local_seen, in this dfs path need to be in sync
- each dfs is like each sub path
- why we do: dfs -> global_seen.add?
- because after dfs all done, global_seen can say we done visit for this node
- why only this question require local_seen.delete after edge loop?
- because denote_max_bomb, max_time_to_inform_employee, critical_connection_in_network; either is using global_seen or local_seen, but none of them do local_seen.del after edge loop
- if we are using global_seen, it does not make sense global_seen.del, why?
- because global_seen.del is global, it needs to persist
- local_seen can be deleted in each dfs path


- https://leetcode.com/problems/course-schedule-ii/ (\*)
- why glocal_seen's entry === course dep order?
- e.g.
- [0, 1] === to do 0, must do 1 first
- graph 0 -> 1
- dfs bottom up, 1 -> 0
- so result === do 1 first, then do 0, which question asking
- e.g.
- [1, 0] === to do 1, must do 0 first
- graph 1 -> 0
- dfs bottom up, 0 -> 1
- so result === do 0 first, then do 1
- summary: course dep order === dfs travel order
- why within dfs, why put local_seen before global_seen?
- because local_seen === cycle; global_seen === avoid_loop
- why return true (local_seen)?
- return === we seen this in own dfs path
- true === cycle, why?
- because seen this in own dfs path, if keep going, cycle
- why return false (global_seen)?
- return === we seen this in global dfs paths
- false === not a cycle, why?
- cycle is detected by local_seen, not our task; not a cycle, because we just seen this
- why put local_seen.del, global_seen.add after dfs?
- because after dfs finish
- why only course_schedule require local_seen.del after edge loop?
- because max_num_denote_bomb, max_time_inform_employee, crital_connection_in_network; either using local_seen or global_seen, but none of them need local_seen.del after edge loop
- it does not make sense, that global_seen.del, why?
- because it is global_seen.del === global, it needs to persistent
- local_seen.del can be done


- https://leetcode.com/problems/critical-connections-in-a-network/ (\*)
- why we put seen.has in outer loop?
- because seen.has in outer loop make it faster.
- seen.has can sit in outer loop and seen.has can sit in dfs, at the same time
- why dfs(child_ind, parent_ind), has child_ind, parent ind?
- because 3 ways: parent -> child -> edge
- why 3 ways?
- because dfs(child_id, parent_ind), then pass dfs(edge_ind, child_ind)
- why we need to label each node with rank?
- otherwise, how do I know which one is more important, which one is on top
- parent -> child -> edge
- why rankAtNode = array(n).fill(-1), why use -1 or 0?
- because the rank starts at 1
- why we have 2 graph assignments?
- beacuse graph[vertex] = edge and graph[edge] = vertex
- why rank starts at 0, not 1?
- because in dfs, we have ++rank, which === 1
- why on top of dfs, ++rank?
- beacuse that is the real dfs rank
- why on top of dfs, we do not check child === parent?
- because we are not checking child === parent, parent (*) -> child -> edge (*)
- we are checking parent === edge, need to skip
- why use Array.from(set) to loop set?
- because set is set, not arr; Array.from can help
- why compare child rank with edge rank, after dfs?
- because child rank and edge rank should have the latest rank
- why assign smaller edge rank to child rank?
- because child rank will be on top once again; parent (top) -> child (bottom 0) -> edge (bottom 1)
- why compare curr_rank with edge rank, after dfs?
- because edge rank should have latest rank;
- curr_rank < edge_rank, that means edge_rank (top) -> curr_rank (bottom), so edge is imporant now -> [edge_ind, child_ind]
- why not curr_rank > edge_rank, then push result? curr_rank (parent) -> edge_rank (child)
- because the prev rankAtNode[child_ind] = min(edge_ind), we update with smaller, so it is similar
- also because we re-arrange parent child order
- why we don't use child_rank VS edge_rank?
- because child_rank keeps updating, it is not stable
- why I use local_seen (path.add -> dfs -> path.del) and global_seen here?
- why we don't use local_seen in critical_net_work_node (leetcode) and denote_max_bomb (leet_code)?
- because this quesion is to detect cycle; then local_seen is a good way to detect cycle

- https://leetcode.com/problems/detonate-the-maximum-bombs/
- why there are 2 ways to init dfs?
- 1. direct dif; e.g. have an init index, then dfs all the way
- 2. loop -> then dfs
- which way to choose?
- for this question, we don't have a single index, so it is likely loop -> then dfs
- when do we use global seen? when do we use local seen?
- if we have loop -> then dfs, then we need to use local seen.
- (because we have multiple init dfs ways, so local seen)
- if we have direct dfs, then we use global seen.
- (because there is 1 dfs way, so use global seen, seen or not seen)
- why we need to have max in outerloop?
- because there is no submax within dfs, there is only acc.
- there is no outerloop max and dfs submax, 
- because each iteration in outerloop, max is enough
- we compare each diff dfs path, and find out the max, among diff dfs paths
- why we use 2D loop to build graph?
- for max time to inform employee question, we use 1D array to build graph
- because we have manager_id = manager_arr[employee_ind]
- for this one, i=0, denote self + rest
- i=1, denote self + rest
- i=2
- so use 2D array to build graph
- for bomb array, why each element === [x, y, radius]?
- because x, y we know the position
- having radius, we can use c^2 = a^2 + b^2, to compare the radius
- if raidus >= the c distance, we can denote; otherwise, we cannot
- why we need to have i_raidus (we use to compare c distance) and j_radius (we don't use)?
- why we need to have x_i, y_i, then x_j, y_j?
- because i stable, then j loop;
- use this way we can exhaust all 1 vs 1 combo
- why we need to use this formula, c^2 = a^2 + b^2?
- because radius_i compare with c distance
- if radius_i >= c, we can denote, then we need to push to edges arr
- this comes up a question, for graph, do I use new Set() or just use arr?
- 1. use arr, we can just push element, we can loop edge loop very easy (many people use this, this question uses)
- 2. use set, set.add(); when loop Array.from(edge_set)
- when we build graph, why we care graph[vertex] init or not?
- not init, graph[vertex] = [], then graph[vertex].push
- already init, graph[vertex].push, directly
- why on top of dfs, why we have acc here, why not submax here?
- becuase we have max in outerloop, to compare.
- here we acc each dfs path, to form acc
- why I cannot use i in edge loop directly, why use e_ind = edges[i]?
- i is not the real thing, it is the index; e_ind = edges[i], is what we push, when build graph
- why we use seen.has within edge loop, not on top of dfs?
- 2 ways to put seen.has
- 1. on top of dfs (for curr)
- 2. within dfs loop (for future)
- why in edge loop, we have ++acc?
- beause it is for this edge iteration, so ++acc; we have other edge iteration
- so at least we finish this edge loop iterations
- then we have ++acc; acc = acc + dfs(edge_index), this level + its sub_level

- https://leetcode.com/problems/time-needed-to-inform-all-employees/
- why there is no loop then dfs?
- becaus we have a single headID
- why we don't need a 2D loop here?
- i loop all employee index
- j loop loop sub employee index
- because manager_arr already have index === employee, val === manager
- then manager_arr[employee_can_also_be_manager] = manager_id
- then graph[manager_id] = employee_id
- when build graph, when loop employee, why i === headID, we skip
- because manager_arr = [-1, 2, 2, 2]
- when i = 0, then val = -1; manager_arr[-1] === undefined, so need to skip
- why only have 1 skip, i === headID; why not more
- we only have 1D employee loop;
- also we only have 1 headId
- why we need submax = Max(submax, dfs(new_head_id)) in edge loop?
- because we have diff dfs paths, we need to get the max
- why timeInform[curr_head_id] + submax?
- timeInform[curr_head_id] === this level
- submax === another dfs level
- why we don't have local_seen here, only global_seen?
- because only course_scheduler (leetcode), ask to detect cycle; this does not ask to detect cycle

- https://leetcode.com/problems/minesweeper/submissions/
- why do we need 8 cell grid directions?
- because 1 click in the middle, all 8 cell grid directions get exploded
- it is like a sun shine.
- why init click has start_row and start_col?
- because that is where we start and we land on the grid.
- why there is no loop then dfs?
- because we have click (start_row, start_col), then we init dfs, then go down
- in the init dfs, why we need to handle mine (M) or init dfs?
- because if we don't handle mine now, it will go down to dfs, dfs will look for all future 8 directions. There is no way to handle current mine
- why we pass 8 directions to dfs?
- because later we have row = curr_row + row_d AND col = curr_col + col_d, for future move
- why the board has the actual value?
- because when we start to to click and dfs each cell, we need to know mine (M, acc num), empty (E, put into dfs queue), blank (B, reveal cell), digit (D, surround mine num), reveal mine (X, explode)
- because we can acc mine num and dfs queue
- why in the top of dfs, we have an empty dfs queue array; why not use a global array?
- because each dfs will have its own click (or starting point); it will hit 8 grid directions and form new dfs queue, in this dfs level.
- next dfs level will have own starting point
- within dfs, why we loop the 8 dir array directly? Why we don't have other loop operation?
- because there is no other operation; we don't need seen.has as there is no cycle hit
- why if we click a cell, it is like a sunshine; shine 8 directions
- because the middle is the central cell, then 8 directions are the shines
- why we loop the 8 directions?
- it can be 4 directions (e.g. flood fill) or 8 directions (mine sweep)
- because it clicks in middle, then it explodes in all 8 directions.
- it form row = curr_row + row_d; col = curr_col + col_d
- why we need row = curr_row + row_d; col = curr_col + col_d?
- because after each direction, we will form a new future move, hence we can check boundary, for future move
- why we only check boundary, we don't have other stuff to check?
- because the next cell will be
- mine (M, looks like a mine)
- empty (E, more dfs path)
- blank (B, reveal blank cell)
- digit (D, surround mine num)
- explode (X, explode mine)
- why there is no seen.has on top of dfs?
- because there is no cycle we will hit, not graph
-
- in dir loop, why we need to care mine (M)?
- because there we acc the mine num, and assign to the click point
- it also helps to stop dfs; because hit the stop point
- why we need to care empty square (E)?
- because if it is empty, we can push to queue arr, then loop -> dfs
- this allows new starting point
- why we don't care blank (B)?
- because aleady known AND there is no contrib to mine acc and dfs queue
- why we don't care digit (D)?
- because known AND there is no contribute to mine acc and dfs queue
- why we don't care explode (X)?
- Because it exploded, it is game over.
- Further to M, E, B, D, X, if other dfs path done it before, current dfs path should ignore it (to avoid repeated action)
- why we acc mine num?
- because need to assign mine num to this starting point.
- why we assign starting point mine num, there is no further dfs?
- because we hit the mine (stop point), we need to stop now, no dfs
- why we assign acc mine num to the starting point's cell?
- because to warn user that there are mines around; it is for the UI of the game
- so why do we assign blank to the starting point?
- because in this dfs level, if click is used, to reveal it, to let UI know.
- the dfs queue is below, is acting like further click (further reveal)
- why we assign blank before next dfs?
- because it is this dfs level, we need to finish the task here
- why the element in queue order is the direction order?
- because we loop in the 8 grid directions, so that is the loop order
- queue order === direction order
- why dfs return, it returns from the bottom?
- because dfs travel from top to bottom, when it reaches a stop condition, it travels from bottom to top, as a whole abstract.
- there is no way for it to travel drectly from starting point
- 
- why we need to use global, local, curr, etc to diff local var and global bar?
- if nested func, it is very easy to confused. must use
- why only empty path (E), we push to the dfs queue?
- because we do not want to dfs easier, must be careful dfs
- why we use board[r][c] = string(mineNum)?
- because all cells are string; why we need to use number
- why above the loop dfs queue, we need to board[r][c] = 'B'?
- because need to clean this cell, then move to next dfs;
- if no clear, we cannot move to next cell


# read, write

- https://leetcode.com/problems/merge-sorted-array (\*)
- https://leetcode.com/problems/duplicate-zeros (\*, brute_force)
- https://leetcode.com/problems/sort-array-by-parity (\*)
- https://leetcode.com/problems/sort-array-by-parity-ii/ (\*)
- https://leetcode.com/problems/remove-duplicates-from-sorted-array (\*)
- https://leetcode.com/problems/remove-element (\*)
- https://leetcode.com/problems/move-zeroes (\*)
- https://www.geeksforgeeks.org/minimum-swaps-required-group-1s-together/
- https://poitevinpm.medium.com/leetcode-2134-minimum-swaps-to-group-all-1s-together-ii-a9a19d85d4f5

# swap

- https://www.geeksforgeeks.org/minimum-swaps-required-group-1s-together/ (\*)
- https://leetcode.com/problems/maximum-swap/ (\*)
- https://leetcode.com/problems/smallest-string-with-swaps/ (x)
- https://leetcode.com/discuss/interview-question/780698/got-this-in-an-interview-how-to-solve (x)
- https://leetcode.com/discuss/interview-question/1517196/Amazon-or-OA-2021-or-Hackerrank, find_min_swap (\*)
- https://leetcode.com/problems/move-zeroes/ (\*)

# Monotonic Stack

- https://leetcode.com/problems/daily-temperatures/ (\*)
- https://leetcode.com/problems/shortest-unsorted-continuous-subarray (\*)
- https://leetcode.com/problems/next-greater-element-i/ (\*)
- https://leetcode.com/problems/next-greater-element-ii/ (\*)
- https://leetcode.com/problems/online-stock-span/ (\*)
- https://leetcode.com/problems/132-pattern/ (\*)
- https://leetcode.com/problems/sum-of-subarray-minimums/ (x)
- https://leetcode.com/problems/largest-rectangle-in-histogram/ (x)
- https://leetcode.com/problems/sum-of-subarray-ranges/

# laser beam

- https://leetcode.com/discuss/interview-question/1669493/AMAZON-OA
- https://leetcode.com/problems/number-of-laser-beams-in-a-bank/description/ (\*)

# pt to orig

- https://leetcode.com/problems/k-closest-points-to-origin/

# paint fence problem

- https://leetcode.com/problems/paint-fence/, https://baihuqian.github.io/2018-07-29-paint-fence/ (x)
- https://leetcode.com/discuss/interview-question/1488281/Amazon-OA (\*)

# https://leetcode.com/discuss/interview-question/1655441/Amazon-or-OA

- it essentially asks for max length of subarray which can product one

A question about Amazon student badges but ultimately the problem was given an arr of -1 or 1, return the maximum subarray length with a product of 1.
The array is of size 2 and above and only contains -1 and 1
e.g arr = [-1,-1,1,1,-1], return 4, since index 0 to 3 have the max length with product equal to 1

I tried to use a sliding window but only passed 4/13 cases. there was somthing i had to fix in the logic for the case arr = [ -1,-1,-1,-1,-1, 1]

Given an array containing only 0 and 1 as its elements. We have to sort the array in such a manner that all the ones are grouped together and all the zeros are grouped together. The group of ones can be either at the start of the array or at the end of the array. The constraint while sorting is that every one/zero can be swapped only with its adjacent zero/one. Find the minimum number of moves to sort the array as per the description.
Example:
input array ={0,1,0,1}
Final array = {0,0,1,1}
Minimum moves = 1 (1 at index 1 is swapped with 0 at index 2)

input array = { 1101}
Final array - {1110}
Minimum moves = 1 {1 at index 2 is swapped with index 3}

I passed all test cases on this one 13/13.

I ran a sliding window to check number of swaps if the elements on the left should be 0s before 1s, and at each 0 found by right index, I found the number of swaps needed
repeated the same above for the case if the elements on the left should be 1s before 0s,
returned the minimum of both operations.

Do I have even a miniscule chance of moving forward

# https://leetcode.com/discuss/interview-question/1557009/amhttps://leetcode.com/discuss/interview-question/1557009/amazon-online-coding-assessment-sde-2

- https://leetcode.com/problems/valid-parentheses/ (\*)
- There are 3 rules for a valid string:

An empty string is valid
You can add same character to a valid string X, and create another valid string yXy
You can concatenate two valid strings X and Y, so XY will also be valid.
Ex: vv, xbbx, bbccdd, xyffyxdd are all valid.
I tried using recursion. but could not complete all test cases. Good approaches or solutions will be helpful.

# parentheses

- https://leetcode.com/problems/generate-parentheses/ (\*)
- https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/ (x)
- https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/ (\*)
- https://leetcode.com/problems/score-of-parentheses/ (\*)
- https://leetcode.com/problems/different-ways-to-add-parentheses/ (\*)
- https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/ (\*)
- https://leetcode.com/problems/valid-parenthesis-string/ (\*)
- https://www.1point3acres.com/bbs/thread-847941-1-1.html
- https://leetcode.com/problems/valid-parentheses/ (\*)

# retail

- https://leetcode.com/discuss/interview-question/1695225/Amazon-OA-or-Part-1-70-Min-or-SDE-Position
- https://leetcode.com/discuss/interview-question/1688875/Amazon-SDE1-or-Number-of-Retailers-who-can-server-given-requests

# product 1

- https://leetcode.com/discuss/interview-question/1692832/Amazon-or-Online-Assessmentor-Product-of-1 (\*)
- https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/ (\*)
- https://leetcode.com/problems/product-of-array-except-self/ (\*)
- https://leetcode.com/problems/maximum-product-subarray/ (look_for_val) (\*)
- https://leetcode.com/problems/sign-of-the-product-of-an-array (\*)
- https://leetcode.com/problems/product-of-the-last-k-numbers/ (\*)
- https://leetcode.com/problems/maximum-product-of-three-numbers/ (\*)
- https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array/ (\*)
- https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/ (\*)

# flip 1 dp

- https://leetcode.com/problems/flip-string-to-monotone-increasing/
